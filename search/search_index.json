{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"MkDocs plugin to show the changes of documentation repositories in a user friendly format, at the same time that it's easy for the authors to maintain. It creates daily, weekly, monthly and yearly newsletter articles with the changes of each period. Those pages, stored under the Newsletters section, are filled with the changes extracted from the commit messages of the git history. The changes are grouped by categories, subcategories and then by file using the order of the site's navigation structure. RSS feeds are also created for each newsletter type, so it's easy for people to keep updated with the evolution of the site. It assumes that you're using semantic versioning or our enhanced version to create your commits. Only those changes that are interesting to the reader will be added to the newsletter. You can use mkdocs-rss-plugin instead if this workflow doesn't feel good. Check a live version . Alternatives \u00b6 mkdocs-rss-plugin \u00b6 This cool plugin creates two RSS feeds for the changes of the git history, one for new files and another for updated ones. Creating an RSS entry for each change, it's not the ideal solution for digital gardens because: The user will receive too many updates : In a normal day, you can edit up to 10 files, which will create 10 RSS entries. That can annoy the user so it will stop reading your feed. The user will receive updates on irrelevant content : As an entry is created for each change, styling and grammar corrections are sent as a new full entry. The user receives no context of the change : The RSS entry links to the article but not it's sections, so if you frequently edit a big file, the, the user will see no point on the entry and skip it and in the end drop the RSS. If you feel that your use case wont suffer from those conditions, I suggest you use their plugin instead, as it's much easier to use. Future plans \u00b6 If there is enough people interested, we may develop: Support more notification channels such as email newsletters . Adding support for software repositories, to give updates on the releases. References \u00b6 As most open sourced programs, mkdocs-newsletter is standing on the shoulders of giants, namely: Pytest Testing framework, enhanced by the awesome pytest-cases library that made the parametrization of the tests a lovely experience. Mypy Python static type checker. Flakehell Python linter with lots of checks . Black Python formatter to keep a nice style without effort. Autoimport Python formatter to automatically fix wrong import statements. isort Python formatter to order the import statements. Pip-tools Command line tool to manage the dependencies. Mkdocs To build this documentation site, with the Material theme . Safety To check the installed dependencies for known security vulnerabilities. Bandit To finds common security issues in Python code. Yamlfix YAML fixer. Contributing \u00b6 For guidance on setting up a development environment, and how to make a contribution to mkdocs-newsletter , see Contributing to mkdocs-newsletter .","title":"Overview"},{"location":"#alternatives","text":"","title":"Alternatives"},{"location":"#mkdocs-rss-plugin","text":"This cool plugin creates two RSS feeds for the changes of the git history, one for new files and another for updated ones. Creating an RSS entry for each change, it's not the ideal solution for digital gardens because: The user will receive too many updates : In a normal day, you can edit up to 10 files, which will create 10 RSS entries. That can annoy the user so it will stop reading your feed. The user will receive updates on irrelevant content : As an entry is created for each change, styling and grammar corrections are sent as a new full entry. The user receives no context of the change : The RSS entry links to the article but not it's sections, so if you frequently edit a big file, the, the user will see no point on the entry and skip it and in the end drop the RSS. If you feel that your use case wont suffer from those conditions, I suggest you use their plugin instead, as it's much easier to use.","title":"mkdocs-rss-plugin"},{"location":"#future-plans","text":"If there is enough people interested, we may develop: Support more notification channels such as email newsletters . Adding support for software repositories, to give updates on the releases.","title":"Future plans"},{"location":"#references","text":"As most open sourced programs, mkdocs-newsletter is standing on the shoulders of giants, namely: Pytest Testing framework, enhanced by the awesome pytest-cases library that made the parametrization of the tests a lovely experience. Mypy Python static type checker. Flakehell Python linter with lots of checks . Black Python formatter to keep a nice style without effort. Autoimport Python formatter to automatically fix wrong import statements. isort Python formatter to order the import statements. Pip-tools Command line tool to manage the dependencies. Mkdocs To build this documentation site, with the Material theme . Safety To check the installed dependencies for known security vulnerabilities. Bandit To finds common security issues in Python code. Yamlfix YAML fixer.","title":"References"},{"location":"#contributing","text":"For guidance on setting up a development environment, and how to make a contribution to mkdocs-newsletter , see Contributing to mkdocs-newsletter .","title":"Contributing"},{"location":"contributing/","text":"So you've started using mkdocs-newsletter and want to show your gratitude to the project, depending on your programming skills there are different ways to do so. I don't know how to program \u00b6 There are several ways you can contribute: Open an issue if you encounter any bug or to let us know if you want a new feature to be implemented. Spread the word about the program. Review the documentation and try to improve it. I know how to program in Python \u00b6 If you have some python knowledge there are some additional ways to contribute. We've ordered the issues in milestones , check the issues in the smaller one, as it's where we'll be spending most of our efforts. Try the good first issues , as they are expected to be easier to get into the project. We develop the program with TDD , so we expect any contribution to have it's associated tests. We also try to maintain an updated documentation of the project, so think if your contribution needs to update it. We know that the expected code quality is above average. Therefore it might be changeling to get the initial grasp of the project structure, know how to make the tests, update the documentation or use all the project technology stack. but please don't let this fact discourage you from contributing: If you want to develop a new feature, explain how you'd like to do it in the related issue. If you don't know how to test your code, do the pull request without the tests and we'll try to do them for you. Issues \u00b6 Questions, feature requests and bug reports are all welcome as issues. To report a security vulnerability, please see our security policy instead. To make it as simple as possible for us to help you, please include the output of the following call in your issue: python -c \"import mkdocs_newsletter.version; print(mkdocs_newsletter.version.version_info())\" or if you have make installed, you can use make version . Please try to always include the above unless you're unable to install mkdocs-newsletter or know it's not relevant to your question or feature request. Pull Requests \u00b6 mkdocs-newsletter is released regularly so you should see your improvements release in a matter of days or weeks. Note Unless your change is trivial (typo, docs tweak etc.), please create an issue to discuss the change before creating a pull request. If you're looking for something to get your teeth into, check out the \"help wanted\" label on github. Development facilities \u00b6 To make contributing as easy and fast as possible, you'll want to run tests and linting locally. tl;dr : use make format to fix formatting, make to run tests and linting & make docs to build the docs. You'll need to have python 3.6, 3.7, or 3.8, virtualenv, git, and make installed. Clone your fork and go into the repository directory: git clone git@github.com:<your username>/mkdocs-newsletter.git cd mkdocs-newsletter Set up the virtualenv for running tests: virtualenv -p ` which python3.7 ` env source env/bin/activate Install mkdocs-newsletter, dependencies and configure the pre-commits: make install Checkout a new branch and make your changes: git checkout -b my-new-feature-branch Fix formatting and imports: mkdocs-newsletter uses black to enforce formatting and isort to fix imports. make format Run tests and linting: make There are more sub-commands in Makefile like test-code , test-examples , mypy or security which you might want to use, but generally make should be all you need. If you need to pass specific arguments to pytest use the ARGS variable, for example make test ARGs='-k test_markdownlint_passes' . Build documentation: If you have changed the documentation, make sure it builds the static site. Once built it will serve the documentation at localhost:8000 : make docs Commit, push, and create your pull request. Make a new release: To generate the changelog of the new changes, build the package, upload to pypi and clean the build files use make bump . We'd love you to contribute to mkdocs-newsletter !","title":"Contributing"},{"location":"contributing/#i-dont-know-how-to-program","text":"There are several ways you can contribute: Open an issue if you encounter any bug or to let us know if you want a new feature to be implemented. Spread the word about the program. Review the documentation and try to improve it.","title":"I don't know how to program"},{"location":"contributing/#i-know-how-to-program-in-python","text":"If you have some python knowledge there are some additional ways to contribute. We've ordered the issues in milestones , check the issues in the smaller one, as it's where we'll be spending most of our efforts. Try the good first issues , as they are expected to be easier to get into the project. We develop the program with TDD , so we expect any contribution to have it's associated tests. We also try to maintain an updated documentation of the project, so think if your contribution needs to update it. We know that the expected code quality is above average. Therefore it might be changeling to get the initial grasp of the project structure, know how to make the tests, update the documentation or use all the project technology stack. but please don't let this fact discourage you from contributing: If you want to develop a new feature, explain how you'd like to do it in the related issue. If you don't know how to test your code, do the pull request without the tests and we'll try to do them for you.","title":"I know how to program in Python"},{"location":"contributing/#issues","text":"Questions, feature requests and bug reports are all welcome as issues. To report a security vulnerability, please see our security policy instead. To make it as simple as possible for us to help you, please include the output of the following call in your issue: python -c \"import mkdocs_newsletter.version; print(mkdocs_newsletter.version.version_info())\" or if you have make installed, you can use make version . Please try to always include the above unless you're unable to install mkdocs-newsletter or know it's not relevant to your question or feature request.","title":"Issues"},{"location":"contributing/#pull-requests","text":"mkdocs-newsletter is released regularly so you should see your improvements release in a matter of days or weeks. Note Unless your change is trivial (typo, docs tweak etc.), please create an issue to discuss the change before creating a pull request. If you're looking for something to get your teeth into, check out the \"help wanted\" label on github.","title":"Pull Requests"},{"location":"contributing/#development-facilities","text":"To make contributing as easy and fast as possible, you'll want to run tests and linting locally. tl;dr : use make format to fix formatting, make to run tests and linting & make docs to build the docs. You'll need to have python 3.6, 3.7, or 3.8, virtualenv, git, and make installed. Clone your fork and go into the repository directory: git clone git@github.com:<your username>/mkdocs-newsletter.git cd mkdocs-newsletter Set up the virtualenv for running tests: virtualenv -p ` which python3.7 ` env source env/bin/activate Install mkdocs-newsletter, dependencies and configure the pre-commits: make install Checkout a new branch and make your changes: git checkout -b my-new-feature-branch Fix formatting and imports: mkdocs-newsletter uses black to enforce formatting and isort to fix imports. make format Run tests and linting: make There are more sub-commands in Makefile like test-code , test-examples , mypy or security which you might want to use, but generally make should be all you need. If you need to pass specific arguments to pytest use the ARGS variable, for example make test ARGs='-k test_markdownlint_passes' . Build documentation: If you have changed the documentation, make sure it builds the static site. Once built it will serve the documentation at localhost:8000 : make docs Commit, push, and create your pull request. Make a new release: To generate the changelog of the new changes, build the package, upload to pypi and clean the build files use make bump . We'd love you to contribute to mkdocs-newsletter !","title":"Development facilities"},{"location":"install/","text":"We've envisioned the plugin with zero configuration as it's quicker to develop and easier to use. If you'd like to change the default behaviour, please open an issue . pip install mkdocs-newsletter To enable this plugin, you need to declare it in your config file mkdocs.yml . plugins : - git-revision-date-localized : type : timeago - autolinks - section-index - mkdocs-newsletter We rely on: git-revision-date-localized to extract the latest modification date for each newsletter for the RSS. mkdocs-autolink-plugin to create the links between the articles. mkdocs-section-index to make the sections clickable. To create the RSS feeds well we also need the next configuration: site_url : https://substitute.with.your.site.url markdown_extensions : - toc : baselevel : 2 MkDocs configuration enhancements \u00b6 There are some MkDocs tweaks that can make the plugin work better: Add newsletter information in the footer and the header . Update the site automatically . Exclude the newsletters from the search . Add newsletter information in the footer and the header \u00b6 It can be useful to let know the readers that you publish the changes through newsletters and RSS feeds, we can do that in the footer and the header. This section is assuming you're using the Material theme. It may work on others but I haven't tested it Footer \u00b6 You can add the RSS icon to the Social links footer section that points to the newsletter landing page with the next snippet: extra : social : - icon : fontawesome/solid/rss link : https://your.site/newsletter/0_newsletter_index/ You can select from fontawesome/solid/rss-square or fontawesome/solid/rss . Header \u00b6 You can add an announce banner at the top telling your readers to subscribe to the RSS feed by extending the theme and overriding the announce block with something like: Assuming that the override theme directory is theme : File: mkdocs.yml theme : name : material custom_dir : theme File: theme/main.html {% extends \"base.html\" %} {% block announce %} <a href=\"https://your.site/newsletter/0_newsletter_index\"> For updates subscribe to the <strong>RSS feed</strong> <span class=\"rss icon\"> {% include \".icons/fontawesome/solid/rss.svg\" %} </span> </a> {% endblock %} Update the site automatically \u00b6 It's useful to create a continuous integration pipeline to keep the site updated and automatically build the newsletters. If you're using github, you can use the next configuration: File: .github/workflows/update.yml --- name : github pages on : push : branches : - master schedule : - cron : 11 08 * * * jobs : deploy : runs-on : ubuntu-latest steps : - uses : actions/checkout@v2 with : persist-credentials : false # Number of commits to fetch. 0 indicates all history. # Default: 1 fetch-depth : 0 - name : Setup Python # https://github.com/actions/virtual-environments/issues/1202 # uses : actions/setup-python@v1 # with : # python-version: '3.7' uses : actions/setup-python@v2 with : python-version : 3.7.7 architecture : x64 - name : Cache dependencies uses : actions/cache@v1 with : path : ~/.cache/pip key : ${{ runner.os }}-pip-${{ hashFiles('**/requirements.txt') }} restore-keys : | ${{ runner.os }}-pip- - name : Install dependencies run : pip install pip-tools - name : Update requirements run : make update - name : Make the site run : make build-docs - name : Commit files run : | git config --local user.email \"action@github.com\" git config --local user.name \"GitHub Action\" git add requirements.txt git add docs/newsletter git diff-index --quiet HEAD \\ || git commit -m \"chore: update dependency and publish newsletters\" - name : Push changes uses : ad-m/github-push-action@master with : github_token : ${{ secrets.GITHUB_TOKEN }} branch : master - name : Deploy uses : peaceiris/actions-gh-pages@v3 with : deploy_key : ${{ secrets.ACTIONS_DEPLOY_KEY }} publish_dir : ./site It assumes that you have the next Makefile : File: Makefile .PHONY : update update : @echo \"-------------------------\" @echo \"- Updating dependencies -\" @echo \"-------------------------\" rm requirements.txt touch requirements.txt pip-compile -Ur requirements.in --allow-unsafe pip install -r requirements.txt @echo \"\" .PHONY : build - docs build-docs : @echo \"--------------------------\" @echo \"- Building documentation -\" @echo \"--------------------------\" mkdocs build @echo \"\" Exclude the newsletters from the search \u00b6 If you don't want to see the newsletters in the result of the search, use the mkdocs-exclude-search plugin to exclude all articles under newsletter/ . To do so: Install the plugin with pip install mkdocs-exclude-search Add the following configuration to your mkdocs.yml plugins : - search - exclude-search : exclude : - newsletter/* Note that newsletter/* excludes all markdown files within a directory and its children. The paths must be relative to the docs/ directory.","title":"Installation"},{"location":"install/#mkdocs-configuration-enhancements","text":"There are some MkDocs tweaks that can make the plugin work better: Add newsletter information in the footer and the header . Update the site automatically . Exclude the newsletters from the search .","title":"MkDocs configuration enhancements"},{"location":"install/#add-newsletter-information-in-the-footer-and-the-header","text":"It can be useful to let know the readers that you publish the changes through newsletters and RSS feeds, we can do that in the footer and the header. This section is assuming you're using the Material theme. It may work on others but I haven't tested it","title":"Add newsletter information in the footer and the header"},{"location":"install/#footer","text":"You can add the RSS icon to the Social links footer section that points to the newsletter landing page with the next snippet: extra : social : - icon : fontawesome/solid/rss link : https://your.site/newsletter/0_newsletter_index/ You can select from fontawesome/solid/rss-square or fontawesome/solid/rss .","title":"Footer"},{"location":"install/#header","text":"You can add an announce banner at the top telling your readers to subscribe to the RSS feed by extending the theme and overriding the announce block with something like: Assuming that the override theme directory is theme : File: mkdocs.yml theme : name : material custom_dir : theme File: theme/main.html {% extends \"base.html\" %} {% block announce %} <a href=\"https://your.site/newsletter/0_newsletter_index\"> For updates subscribe to the <strong>RSS feed</strong> <span class=\"rss icon\"> {% include \".icons/fontawesome/solid/rss.svg\" %} </span> </a> {% endblock %}","title":"Header"},{"location":"install/#update-the-site-automatically","text":"It's useful to create a continuous integration pipeline to keep the site updated and automatically build the newsletters. If you're using github, you can use the next configuration: File: .github/workflows/update.yml --- name : github pages on : push : branches : - master schedule : - cron : 11 08 * * * jobs : deploy : runs-on : ubuntu-latest steps : - uses : actions/checkout@v2 with : persist-credentials : false # Number of commits to fetch. 0 indicates all history. # Default: 1 fetch-depth : 0 - name : Setup Python # https://github.com/actions/virtual-environments/issues/1202 # uses : actions/setup-python@v1 # with : # python-version: '3.7' uses : actions/setup-python@v2 with : python-version : 3.7.7 architecture : x64 - name : Cache dependencies uses : actions/cache@v1 with : path : ~/.cache/pip key : ${{ runner.os }}-pip-${{ hashFiles('**/requirements.txt') }} restore-keys : | ${{ runner.os }}-pip- - name : Install dependencies run : pip install pip-tools - name : Update requirements run : make update - name : Make the site run : make build-docs - name : Commit files run : | git config --local user.email \"action@github.com\" git config --local user.name \"GitHub Action\" git add requirements.txt git add docs/newsletter git diff-index --quiet HEAD \\ || git commit -m \"chore: update dependency and publish newsletters\" - name : Push changes uses : ad-m/github-push-action@master with : github_token : ${{ secrets.GITHUB_TOKEN }} branch : master - name : Deploy uses : peaceiris/actions-gh-pages@v3 with : deploy_key : ${{ secrets.ACTIONS_DEPLOY_KEY }} publish_dir : ./site It assumes that you have the next Makefile : File: Makefile .PHONY : update update : @echo \"-------------------------\" @echo \"- Updating dependencies -\" @echo \"-------------------------\" rm requirements.txt touch requirements.txt pip-compile -Ur requirements.in --allow-unsafe pip install -r requirements.txt @echo \"\" .PHONY : build - docs build-docs : @echo \"--------------------------\" @echo \"- Building documentation -\" @echo \"--------------------------\" mkdocs build @echo \"\"","title":"Update the site automatically"},{"location":"install/#exclude-the-newsletters-from-the-search","text":"If you don't want to see the newsletters in the result of the search, use the mkdocs-exclude-search plugin to exclude all articles under newsletter/ . To do so: Install the plugin with pip install mkdocs-exclude-search Add the following configuration to your mkdocs.yml plugins : - search - exclude-search : exclude : - newsletter/* Note that newsletter/* excludes all markdown files within a directory and its children. The paths must be relative to the docs/ directory.","title":"Exclude the newsletters from the search"},{"location":"reference/","text":"mkdocs_newsletter special \u00b6 Automatically create newsletters from the changes in a mkdocs repository. adapters special \u00b6 Module to store the functions shared by the different adapters. entrypoints special \u00b6 Define the different ways to expose the program functionality. mkdocs_plugin \u00b6 Define the mkdocs plugin. Newsletter \u00b6 Define the MkDocs plugin to create newsletters. __init__ ( self ) special \u00b6 Initialize the basic attributes. Attributes: Name Type Description repo Git repository to analyze. Source code in mkdocs_newsletter/entrypoints/mkdocs_plugin.py def __init__ ( self ) -> None : \"\"\"Initialize the basic attributes. Attributes: repo: Git repository to analyze. \"\"\" self . working_dir = os . getenv ( \"NEWSLETTER_WORKING_DIR\" , default = os . getcwd ()) self . repo = Repo ( self . working_dir ) on_config ( self , config ) \u00b6 Create the new newsletters and load them in the navigation. Through the following steps: Detect which were the last changes for each of the feeds. Parse the changes from the git history that were done before the last changes. Create the newsletter articles. Update the navigation. Parameters: Name Type Description Default config Config MkDocs global configuration object. required Returns: Type Description Config Source code in mkdocs_newsletter/entrypoints/mkdocs_plugin.py def on_config ( self , config : Config ) -> Config : \"\"\"Create the new newsletters and load them in the navigation. Through the following steps: * Detect which were the last changes for each of the feeds. * Parse the changes from the git history that were done before the last changes. * Create the newsletter articles. * Update the navigation. Args: config: MkDocs global configuration object. Returns: config: MkDocs config object with the new newsletters in the Newsletter section. \"\"\" newsletter_dir = f \" { self . working_dir } /docs/newsletter\" if not os . path . exists ( newsletter_dir ): os . makedirs ( newsletter_dir ) last_published_changes = last_newsletter_changes ( newsletter_dir ) changes_to_publish = add_change_categories ( semantic_changes ( self . repo , last_published_changes . min ()), config ) changes_per_feed = digital_garden_changes ( changes_to_publish , last_published_changes , ) create_newsletters ( changes_per_feed , self . repo ) create_newsletter_landing_page ( config , self . repo ) config = build_nav ( config , newsletter_dir ) return config on_post_build ( self , config ) \u00b6 Create the RSS feeds. Source code in mkdocs_newsletter/entrypoints/mkdocs_plugin.py def on_post_build ( self , config : Config ) -> None : \"\"\"Create the RSS feeds.\"\"\" create_rss ( config , self . working_dir ) model \u00b6 Module to store the common business model of all entities. Change pydantic-model \u00b6 Represent a single semantic change in a git repository. Attributes: Name Type Description date datetime When the change was done. summary str short description of the change. type_ Optional[str] semantic type of change, such as feature or fix. message Optional[str] long description of the change. breaking bool if the change breaks previous functionality. category Optional[str] name of the group of files that share meaning. category_order Optional[int] order of the category against all categories. subcategory Optional[str] name of the subgroup of files that share meaning. category_order Optional[int] order of the subcategory against all subcategories. file_ Optional[str] markdown file name. file_section Optional[str] title of the file containing the change. file_section_order Optional[int] order of the file in the subcategory or category that holds the file. file_subsection Optional[str] title of the section of the file the change belongs to. DigitalGardenChanges pydantic-model \u00b6 Represents all changes that need to be published for each feed type. Feed pydantic-model \u00b6 Model an RSS feed. FeedEntry pydantic-model \u00b6 Model an RSS feed entry. __gt__ ( self , other ) special \u00b6 Assert if an object is greater than us. Parameters: Name Type Description Default other FeedEntry FeedEntry to compare. required Exceptions: Type Description TypeError If the id type of the objects is not compatible. Source code in mkdocs_newsletter/model.py def __gt__ ( self , other : \"FeedEntry\" ) -> bool : \"\"\"Assert if an object is greater than us. Args: other: FeedEntry to compare. Raises: TypeError: If the id type of the objects is not compatible. \"\"\" return self . published > other . published __lt__ ( self , other ) special \u00b6 Assert if an object is smaller than us. Parameters: Name Type Description Default other FeedEntry FeedEntry to compare. required Exceptions: Type Description TypeError If the id type of the objects is not compatible. Source code in mkdocs_newsletter/model.py def __lt__ ( self , other : \"FeedEntry\" ) -> bool : \"\"\"Assert if an object is smaller than us. Args: other: FeedEntry to compare. Raises: TypeError: If the id type of the objects is not compatible. \"\"\" return self . published < other . published LastNewsletter pydantic-model \u00b6 Represents the last newsletter for each feed type. min ( self ) \u00b6 Return the smallest date of all the feeds. Source code in mkdocs_newsletter/model.py def min ( self ) -> Optional [ datetime ]: \"\"\"Return the smallest date of all the feeds.\"\"\" try : return min ( value for key , value in self . dict () . items () if value is not None ) except ValueError : return None Newsletter pydantic-model \u00b6 Represents a newsletter. __gt__ ( self , other ) special \u00b6 Assert if an object is greater than us. Parameters: Name Type Description Default other Newsletter Newsletter to compare. required Exceptions: Type Description TypeError If the id type of the objects is not compatible. Source code in mkdocs_newsletter/model.py def __gt__ ( self , other : \"Newsletter\" ) -> bool : \"\"\"Assert if an object is greater than us. Args: other: Newsletter to compare. Raises: TypeError: If the id type of the objects is not compatible. \"\"\" return self . basename > other . basename __lt__ ( self , other ) special \u00b6 Assert if an object is smaller than us. Parameters: Name Type Description Default other Newsletter Newsletter to compare. required Exceptions: Type Description TypeError If the id type of the objects is not compatible. Source code in mkdocs_newsletter/model.py def __lt__ ( self , other : \"Newsletter\" ) -> bool : \"\"\"Assert if an object is smaller than us. Args: other: Newsletter to compare. Raises: TypeError: If the id type of the objects is not compatible. \"\"\" return self . basename < other . basename set_attributes ( values ) classmethod \u00b6 Set the class attributes. basename: basename of the file. type_: Set the type of the newsletter. date: Set the datetime associated to the file name. Source code in mkdocs_newsletter/model.py @root_validator ( pre = True ) @classmethod def set_attributes ( cls , values : Dict [ str , Any ]) -> Dict [ str , Any ]: \"\"\"Set the class attributes. * basename: basename of the file. * type_: Set the type of the newsletter. * date: Set the datetime associated to the file name. \"\"\" basename = os . path . splitext ( values [ \"file_\" ] . name )[ 0 ] values [ \"basename\" ] = basename if re . match ( r \"\\d {4} $\" , basename ): values [ \"type_\" ] = \"yearly\" values [ \"date\" ] = datetime ( int ( basename ), 1 , 1 , tzinfo = tz . tzlocal ()) elif re . match ( r \"\\d {4} _\\d {2} $\" , basename ): values [ \"type_\" ] = \"monthly\" year = int ( basename . split ( \"_\" )[ 0 ]) month = int ( basename . split ( \"_\" )[ 1 ]) values [ \"date\" ] = datetime ( year , month , 1 , tzinfo = tz . tzlocal ()) elif re . match ( r \"\\d {4} _w\\d {2} $\" , basename ): values [ \"type_\" ] = \"weekly\" year = int ( basename . split ( \"_\" )[ 0 ]) week = int ( basename . split ( \"w\" )[ 1 ]) first_day = datetime ( year , 1 , 1 , tzinfo = tz . tzlocal ()) values [ \"date\" ] = first_day + timedelta ( days = 7 * ( week - 1 ) - first_day . weekday () ) elif re . match ( r \"\\d {4} _\\d {2} _\\d {2} $\" , basename ): values [ \"type_\" ] = \"daily\" values [ \"date\" ] = datetime . strptime ( basename , \"%Y_%m_ %d \" ) . replace ( tzinfo = tz . tzlocal () ) return values Newsletters pydantic-model \u00b6 Represents the newsletters for each feed type. sort ( self ) \u00b6 Sort the newsletters. Source code in mkdocs_newsletter/model.py def sort ( self ) -> None : \"\"\"Sort the newsletters.\"\"\" self . yearly = sorted ( self . yearly , reverse = True ) self . monthly = sorted ( self . monthly , reverse = True ) self . weekly = sorted ( self . weekly , reverse = True ) self . daily = sorted ( self . daily , reverse = True ) NewsletterSection pydantic-model \u00b6 Represent the section of a newsletter article. Attributes: Name Type Description title str Category title order int The order in comparison with the other categories changes List[mkdocs_newsletter.model.Change] Changes to be printed in the section subsections List[mkdocs_newsletter.model.NewsletterSection] A list of subsections. __gt__ ( self , other ) special \u00b6 Assert if an object is greater than us. Parameters: Name Type Description Default other NewsletterSection NewsletterSection to compare. required Exceptions: Type Description TypeError If the id type of the objects is not compatible. Source code in mkdocs_newsletter/model.py def __gt__ ( self , other : \"NewsletterSection\" ) -> bool : \"\"\"Assert if an object is greater than us. Args: other: NewsletterSection to compare. Raises: TypeError: If the id type of the objects is not compatible. \"\"\" return self . order < other . order __lt__ ( self , other ) special \u00b6 Assert if an object is smaller than us. Parameters: Name Type Description Default other NewsletterSection NewsletterSection to compare. required Exceptions: Type Description TypeError If the id type of the objects is not compatible. Source code in mkdocs_newsletter/model.py def __lt__ ( self , other : \"NewsletterSection\" ) -> bool : \"\"\"Assert if an object is smaller than us. Args: other: NewsletterSection to compare. Raises: TypeError: If the id type of the objects is not compatible. \"\"\" return self . order > other . order NewsletterType \u00b6 Defines the possible newsletter types. services special \u00b6 git \u00b6 Gather all the orchestration functionality required by the program to work. Classes and functions that connect the different domain model objects with the adapters and handlers to achieve the program's purpose. commit_to_changes ( commit ) \u00b6 Extract the semantic changes from a commit. Parameters: Name Type Description Default commit Commit Commit to parse. required Returns: Type Description List[mkdocs_newsletter.model.Change] Source code in mkdocs_newsletter/services/git.py def commit_to_changes ( commit : Commit ) -> List [ Change ]: \"\"\"Extract the semantic changes from a commit. Args: commit: Commit to parse. Returns: changes: List of semantic changes. \"\"\" changes : List [ Change ] = [] remaining = commit . message while remaining is not None : try : change , remaining = _parse_change ( remaining , commit . authored_date ) except ValueError : return changes changes . append ( change ) return changes commits_to_changes ( commits ) \u00b6 Extract the semantic changes from a list of commits. Parameters: Name Type Description Default commits List[git.objects.commit.Commit] List of commits to parse. required Returns: Type Description List[mkdocs_newsletter.model.Change] Source code in mkdocs_newsletter/services/git.py def commits_to_changes ( commits : List [ Commit ]) -> List [ Change ]: \"\"\"Extract the semantic changes from a list of commits. Args: commits: List of commits to parse. Returns: changes: List of semantic changes. \"\"\" changes = [] for commit in commits : with suppress ( ValueError ): changes += commit_to_changes ( commit ) return changes semantic_changes ( repo , min_date = None ) \u00b6 Extract meaningful changes from a git repository. Parameters: Name Type Description Default repo Repo Git repository to analyze. required Returns: Type Description List[mkdocs_newsletter.model.Change] Source code in mkdocs_newsletter/services/git.py def semantic_changes ( repo : Repo , min_date : Optional [ datetime . datetime ] = None ) -> List [ Change ]: \"\"\"Extract meaningful changes from a git repository. Args: repo: Git repository to analyze. Returns: changes: List of Change objects. \"\"\" now = datetime . datetime . now ( tz = tz . tzlocal ()) if min_date is None : min_date = datetime . datetime ( 1800 , 1 , 1 , tzinfo = tz . tzlocal ()) commits = [ commit for commit in repo . iter_commits ( rev = repo . head . reference ) if commit . authored_datetime < now and commit . authored_datetime > min_date ] return commits_to_changes ( commits ) nav \u00b6 Gather services to create the newsletters MkDocs nav section. build_nav ( config , newsletter_dir ) \u00b6 Build the navigation section of the newsletters. Parameters: Name Type Description Default config Config MkDocs configuration object. required newsletter_dir str Directory containing the newsletter articles. required Returns: Type Description Config The config object with the newsletters. Source code in mkdocs_newsletter/services/nav.py def build_nav ( config : Config , newsletter_dir : str ) -> Config : \"\"\"Build the navigation section of the newsletters. Args: config: MkDocs configuration object. newsletter_dir: Directory containing the newsletter articles. Returns: The config object with the newsletters. \"\"\" nav_data : Dict [ Union [ int , str ], Any ] = {} newsletter_regex = ( r \"(?P<year>\\d {4} )\" r \"(_w(?P<week_number>\\d {2} ))?\" r \"(_(?P<month>\\d {2} ))?\" r \"(_(?P<day>\\d {2} ))?.md\" ) for file_ in os . scandir ( newsletter_dir ): file_path = f \"newsletter/ { file_ . name } \" match = re . match ( newsletter_regex , file_ . name ) if match is None : if file_ . name == \"0_newsletter_index.md\" : nav_data [ \"index\" ] = file_path continue year_match = match . group ( \"year\" ) week_match = match . group ( \"week_number\" ) month_match = match . group ( \"month\" ) day_match = match . group ( \"day\" ) if year_match is not None : year = int ( year_match ) nav_data . setdefault ( year , {}) if month_match is not None : month = int ( month_match ) nav_data [ year ] . setdefault ( month , {}) if day_match is not None : day = int ( day_match ) week = datetime . datetime ( year , month , day ) . isocalendar ()[ 1 ] nav_data [ year ][ month ] . setdefault ( week , {}) nav_data [ year ][ month ][ week ][ day ] = file_path else : nav_data [ year ][ month ][ \"index\" ] = file_path elif week_match is not None : week = int ( week_match ) month = datetime . datetime . strptime ( f \" { year }{ week } -1\" , \"%Y%W-%w\" ) . month nav_data [ year ] . setdefault ( month , {}) nav_data [ year ][ month ] . setdefault ( week , {}) nav_data [ year ][ month ][ week ][ \"index\" ] = file_path else : nav_data [ year ][ \"index\" ] = file_path return _nav_data_to_nav ( nav_data , config ) newsletter \u00b6 Gather services related to the management of the newsletters. add_change_categories ( changes , config ) \u00b6 Add category and subcategory to each change based on their file nav position. Parameters: Name Type Description Default changes List[mkdocs_newsletter.model.Change] The list of Change objects to process. required config Config MkDocs Config object. required Returns: Type Description List[mkdocs_newsletter.model.Change] Updated list of changes. Source code in mkdocs_newsletter/services/newsletter.py def add_change_categories ( changes : List [ Change ], config : Config ) -> List [ Change ]: \"\"\"Add category and subcategory to each change based on their file nav position. Args: changes: The list of Change objects to process. config: MkDocs Config object. Returns: Updated list of changes. \"\"\" for change in changes : if change . scope is not None : scope_parts = change . scope . split ( \"#\" ) change . file_ = f \" { scope_parts [ 0 ] } .md\" if len ( scope_parts ) > 1 : change . file_subsection = \"#\" + scope_parts [ 1 ] . lower () . replace ( \" \" , \"-\" ) nav_search = config [ \"nav\" ] | grep ( change . file_ ) try : nav_path = nav_search [ \"matched_values\" ][ 0 ] except KeyError : change . category = \"Other\" change . category_order = 999 change . file_ = None change . file_subsection = None continue more_than_three_levels_regex = ( r \"root\" r \"\\[(?P<category_order>\\d+)\\]\" r \"\\['(?P<category>[\\w\\s]+)'\\]\" r \"\\[(?P<subcategory_order>\\d+)\\]\" r \"\\['(?P<subcategory>[\\w\\s]+)'\\]\" r \"(\\[(?P<other_level_order>\\d+)\\]\" r \"\\['(?P<other_level_category>[\\w\\s]+)'\\])+\" r \"\\[(?P<file_section_order>\\d+)\\]\" r \"\\['(?P<file_section>[\\w\\s]+)'\\]\" r \"(\\[(?P<is_section>\\d+)\\])?\" ) less_than_four_levels_regex = ( r \"root\" r \"\\[(?P<category_order>\\d+)\\]\" r \"\\['(?P<category>[\\w\\s]+)'\\]\" r \"(\\[(?P<subcategory_order>\\d+)\\])?\" r \"(\\['(?P<subcategory>[\\w\\s]+)'\\])?\" r \"(\\[(?P<file_section_order>\\d+)\\])?\" r \"(\\['(?P<file_section>[\\w\\s]+)'\\])?\" r \"(\\[(?P<is_section>\\d+)\\])?\" ) match = re . match ( more_than_three_levels_regex , nav_path ) if match is None : match = re . match ( less_than_four_levels_regex , nav_path ) if match is not None : change . category = match . group ( \"category\" ) change . category_order = int ( match . group ( \"category_order\" )) change . subcategory = match . group ( \"subcategory\" ) if change . subcategory is not None : change . subcategory_order = int ( match . group ( \"subcategory_order\" )) change . file_section = match . group ( \"file_section\" ) if change . file_section is not None : change . file_section_order = int ( match . group ( \"file_section_order\" )) return changes create_newsletter ( changes ) \u00b6 Build the newsletter article test from the changes. Group first by category, then by subcategory and then by file. Parameters: Name Type Description Default changes List[mkdocs_newsletter.model.Change] List of changes to publish in the article required Returns: Type Description str Article markdown text. Source code in mkdocs_newsletter/services/newsletter.py def create_newsletter ( changes : List [ Change ]) -> str : \"\"\"Build the newsletter article test from the changes. Group first by category, then by subcategory and then by file. Args: changes: List of changes to publish in the article Returns: Article markdown text. \"\"\" env = Environment ( loader = PackageLoader ( \"mkdocs_newsletter\" , \"templates\" ), autoescape = select_autoescape ([ \"html\" , \"xml\" ]), ) template = env . get_template ( \"newsletter_article.j2\" ) sections = _build_newsletter_sections ( changes ) article = template . render ( sections = sections , change_type_text = CHANGE_TYPE_TEXT ) article = re . sub ( r \"\\n\\n+\" , r \"\\n\\n\" , article ) . strip () return article create_newsletter_landing_page ( config , repo ) \u00b6 Create the newsletter landing page. Source code in mkdocs_newsletter/services/newsletter.py def create_newsletter_landing_page ( config : Config , repo : Repo ) -> None : \"\"\"Create the newsletter landing page.\"\"\" base_dir = repo . working_dir landing_path = os . path . join ( base_dir , \"docs/newsletter/0_newsletter_index.md\" ) if not os . path . isfile ( landing_path ): env = Environment ( loader = PackageLoader ( \"mkdocs_newsletter\" , \"templates\" ), autoescape = select_autoescape ([ \"html\" , \"xml\" ]), ) template = env . get_template ( \"newsletter_landing_page.j2\" ) landing_page = template . render ( site_url = config [ \"site_url\" ]) with open ( landing_path , \"+w\" ) as landing_file : landing_file . write ( landing_page ) create_newsletters ( changes , repo ) \u00b6 Create the newsletter articles from the semantic changes for all feeds. Fills the newsletter article jinja2 template and creates the related File objects. Parameters: Name Type Description Default changes DigitalGardenChanges The list of Change objects to publish per feed. required repo Repo Git Repo object with the MkDocs repository. required Returns: Type Description List[str] List of file paths with the newsletter articles. Source code in mkdocs_newsletter/services/newsletter.py def create_newsletters ( changes : DigitalGardenChanges , repo : Repo ) -> List [ str ]: \"\"\"Create the newsletter articles from the semantic changes for all feeds. Fills the newsletter article jinja2 template and creates the related File objects. Args: changes: The list of Change objects to publish per feed. repo: Git Repo object with the MkDocs repository. Returns: List of file paths with the newsletter articles. \"\"\" base_dir = repo . working_dir files = ( _create_feed_articles ( changes . daily , _get_daily_newsletter_file , base_dir ) + _create_feed_articles ( changes . weekly , _get_weekly_newsletter_file , base_dir ) + _create_feed_articles ( changes . monthly , _get_monthly_newsletter_file , base_dir ) + _create_feed_articles ( changes . yearly , _get_yearly_newsletter_file , base_dir ) ) return files digital_garden_changes ( changes , last_published = None ) \u00b6 Extract the changes that need to be published for digital_garden repositories. For a change to be published it needs to: Be made before the first day of the year and after the last published change in the year feed. Be made before the first day of the month and after the last published change in the month feed. Be made before the last Monday and after the last published change in the week feed. day: Be made before today and after the last published change in the day feed. Parameters: Name Type Description Default changes List[mkdocs_newsletter.model.Change] The list of Change objects to publish. required last_published Optional[mkdocs_newsletter.model.LastNewsletter] last published date per feed type None Returns: Type Description DigitalGardenChanges Source code in mkdocs_newsletter/services/newsletter.py def digital_garden_changes ( changes : List [ Change ], last_published : Optional [ LastNewsletter ] = None ) -> DigitalGardenChanges : \"\"\"Extract the changes that need to be published for digital_garden repositories. For a change to be published it needs to: year: Be made before the first day of the year and after the last published change in the year feed. month: Be made before the first day of the month and after the last published change in the month feed. week: Be made before the last Monday and after the last published change in the week feed. day: Be made before today and after the last published change in the day feed. Args: changes: The list of Change objects to publish. last_published: last published date per feed type Returns: changes: Ordered changes to publish per feed. \"\"\" now = datetime . datetime . now ( tz . tzlocal ()) today = now . replace ( hour = 0 , minute = 0 , second = 0 , microsecond = 0 ) last_first_weekday = today - datetime . timedelta ( days = now . weekday ()) last_first_monthday = today . replace ( day = 1 ) last_first_yearday = today . replace ( day = 1 , month = 1 ) if last_published is None : last_published = LastNewsletter () return DigitalGardenChanges ( daily = [ change for change in changes if change . date < today and ( last_published . daily is None or change . date > last_published . daily ) and change . type_ in CHANGE_TYPE_TEXT ], weekly = [ change for change in changes if change . date < last_first_weekday and ( last_published . weekly is None or change . date > last_published . weekly ) and change . type_ in CHANGE_TYPE_TEXT ], monthly = [ change for change in changes if change . date < last_first_monthday and ( last_published . monthly is None or change . date > last_published . monthly ) and change . type_ in CHANGE_TYPE_TEXT ], yearly = [ change for change in changes if change . date < last_first_yearday and ( last_published . yearly is None or change . date > last_published . yearly ) and change . type_ in CHANGE_TYPE_TEXT ], ) last_newsletter_changes ( newsletter_dir ) \u00b6 Extract the date of the last change of the last newsletter for each feed. Parameters: Name Type Description Default newsletter_dir str Directory containing the newsletter articles. required Returns: Type Description LastNewsletter Source code in mkdocs_newsletter/services/newsletter.py def last_newsletter_changes ( newsletter_dir : str ) -> LastNewsletter : \"\"\"Extract the date of the last change of the last newsletter for each feed. Args: newsletter_dir: Directory containing the newsletter articles. Returns: last_newsletter: LastNewsletter object. \"\"\" newsletters = _list_newsletters ( newsletter_dir ) last = LastNewsletter () # Year feed: Saves the first day of the next year. with suppress ( IndexError ): last . yearly = newsletters . yearly [ 0 ] . date + relativedelta ( years = 1 ) # Month feed: Saves the first day of the next month. with suppress ( IndexError ): last_file_date = newsletters . monthly [ 0 ] . date last . monthly = datetime . datetime ( last_file_date . year + int ( last_file_date . month / 12 ), (( last_file_date . month % 12 ) + 1 ), 1 , tzinfo = tz . tzlocal (), ) # Week feed: Saves the next Monday from the week of the week number. with suppress ( IndexError ): last . weekly = newsletters . weekly [ 0 ] . date + datetime . timedelta ( days = 7 ) # Daily feed: Saves the next day. with suppress ( IndexError ): last . daily = newsletters . daily [ 0 ] . date + datetime . timedelta ( days = 1 ) return last rss \u00b6 Define the RSS management services. build_rss_feed ( config , working_dir , type_ ) \u00b6 Create the RSS feed data from the content. Parameters: Name Type Description Default config Config MkDocs config object. required type_ str type of feed, one of: daily, weekly, monthly or yearly. required Returns: Type Description Feed Feed object with the data Source code in mkdocs_newsletter/services/rss.py def build_rss_feed ( config : Config , working_dir : str , type_ : str ) -> Feed : \"\"\"Create the RSS feed data from the content. Args: config: MkDocs config object. type_: type of feed, one of: daily, weekly, monthly or yearly. Returns: Feed object with the data \"\"\" site_url = config [ \"site_url\" ] try : logo_url : Optional [ str ] = f \" { site_url } / { config [ 'theme' ][ 'logo' ] } \" except KeyError : logo_url = None author = config . get ( \"site_author\" , None ) entries = _build_rss_entries ( config , working_dir , type_ , author ) try : published = max ( entries ) . published except ValueError : published = datetime . datetime . now () return Feed ( ttl = TTL [ type_ ], generator = f \"mkdocs-newsletter - v { __version__ } \" , title = config . get ( \"site_name\" , None ), link = site_url , rss_link = f \" { site_url } / { type_ } .xml\" , logo = logo_url , description = config . get ( \"site_description\" , None ), author = author , published = published , entries = entries , ) create_rss ( config , working_dir ) \u00b6 Create RSS feed with the newsletters of a period. Source code in mkdocs_newsletter/services/rss.py def create_rss ( config : Config , working_dir : str ) -> None : \"\"\"Create RSS feed with the newsletters of a period.\"\"\" feed_types = [ type_ . value for type_ in NewsletterType ] for feed_type in feed_types : feed = build_rss_feed ( config , working_dir , feed_type ) env = Environment ( loader = PackageLoader ( \"mkdocs_newsletter\" , \"templates\" ), autoescape = select_autoescape ([ \"html\" , \"xml\" ]), ) template = env . get_template ( \"rss.xml.j2\" ) feed_path = os . path . join ( config [ \"site_dir\" ], f \" { feed_type } .xml\" ) feed_content = template . render ( feed = feed ) with open ( feed_path , \"+w\" ) as feed_file : feed_file . write ( feed_content ) version \u00b6 Utilities to retrieve the information of the program version. version_info () \u00b6 Display the version of the program, python and the platform. Source code in mkdocs_newsletter/version.py def version_info () -> str : \"\"\"Display the version of the program, python and the platform.\"\"\" info = { \"mkdocs_newsletter version\" : __version__ , \"python version\" : sys . version . replace ( \" \\n \" , \" \" ), \"platform\" : platform . platform (), } return \" \\n \" . join ( f \" { k + ':' : >30 } { v } \" for k , v in info . items ())","title":"Reference"},{"location":"reference/#mkdocs_newsletter","text":"Automatically create newsletters from the changes in a mkdocs repository.","title":"mkdocs_newsletter"},{"location":"reference/#mkdocs_newsletter.adapters","text":"Module to store the functions shared by the different adapters.","title":"adapters"},{"location":"reference/#mkdocs_newsletter.entrypoints","text":"Define the different ways to expose the program functionality.","title":"entrypoints"},{"location":"reference/#mkdocs_newsletter.entrypoints.mkdocs_plugin","text":"Define the mkdocs plugin.","title":"mkdocs_plugin"},{"location":"reference/#mkdocs_newsletter.entrypoints.mkdocs_plugin.Newsletter","text":"Define the MkDocs plugin to create newsletters.","title":"Newsletter"},{"location":"reference/#mkdocs_newsletter.entrypoints.mkdocs_plugin.Newsletter.__init__","text":"Initialize the basic attributes. Attributes: Name Type Description repo Git repository to analyze. Source code in mkdocs_newsletter/entrypoints/mkdocs_plugin.py def __init__ ( self ) -> None : \"\"\"Initialize the basic attributes. Attributes: repo: Git repository to analyze. \"\"\" self . working_dir = os . getenv ( \"NEWSLETTER_WORKING_DIR\" , default = os . getcwd ()) self . repo = Repo ( self . working_dir )","title":"__init__()"},{"location":"reference/#mkdocs_newsletter.entrypoints.mkdocs_plugin.Newsletter.on_config","text":"Create the new newsletters and load them in the navigation. Through the following steps: Detect which were the last changes for each of the feeds. Parse the changes from the git history that were done before the last changes. Create the newsletter articles. Update the navigation. Parameters: Name Type Description Default config Config MkDocs global configuration object. required Returns: Type Description Config Source code in mkdocs_newsletter/entrypoints/mkdocs_plugin.py def on_config ( self , config : Config ) -> Config : \"\"\"Create the new newsletters and load them in the navigation. Through the following steps: * Detect which were the last changes for each of the feeds. * Parse the changes from the git history that were done before the last changes. * Create the newsletter articles. * Update the navigation. Args: config: MkDocs global configuration object. Returns: config: MkDocs config object with the new newsletters in the Newsletter section. \"\"\" newsletter_dir = f \" { self . working_dir } /docs/newsletter\" if not os . path . exists ( newsletter_dir ): os . makedirs ( newsletter_dir ) last_published_changes = last_newsletter_changes ( newsletter_dir ) changes_to_publish = add_change_categories ( semantic_changes ( self . repo , last_published_changes . min ()), config ) changes_per_feed = digital_garden_changes ( changes_to_publish , last_published_changes , ) create_newsletters ( changes_per_feed , self . repo ) create_newsletter_landing_page ( config , self . repo ) config = build_nav ( config , newsletter_dir ) return config","title":"on_config()"},{"location":"reference/#mkdocs_newsletter.entrypoints.mkdocs_plugin.Newsletter.on_post_build","text":"Create the RSS feeds. Source code in mkdocs_newsletter/entrypoints/mkdocs_plugin.py def on_post_build ( self , config : Config ) -> None : \"\"\"Create the RSS feeds.\"\"\" create_rss ( config , self . working_dir )","title":"on_post_build()"},{"location":"reference/#mkdocs_newsletter.model","text":"Module to store the common business model of all entities.","title":"model"},{"location":"reference/#mkdocs_newsletter.model.Change","text":"Represent a single semantic change in a git repository. Attributes: Name Type Description date datetime When the change was done. summary str short description of the change. type_ Optional[str] semantic type of change, such as feature or fix. message Optional[str] long description of the change. breaking bool if the change breaks previous functionality. category Optional[str] name of the group of files that share meaning. category_order Optional[int] order of the category against all categories. subcategory Optional[str] name of the subgroup of files that share meaning. category_order Optional[int] order of the subcategory against all subcategories. file_ Optional[str] markdown file name. file_section Optional[str] title of the file containing the change. file_section_order Optional[int] order of the file in the subcategory or category that holds the file. file_subsection Optional[str] title of the section of the file the change belongs to.","title":"Change"},{"location":"reference/#mkdocs_newsletter.model.DigitalGardenChanges","text":"Represents all changes that need to be published for each feed type.","title":"DigitalGardenChanges"},{"location":"reference/#mkdocs_newsletter.model.Feed","text":"Model an RSS feed.","title":"Feed"},{"location":"reference/#mkdocs_newsletter.model.FeedEntry","text":"Model an RSS feed entry.","title":"FeedEntry"},{"location":"reference/#mkdocs_newsletter.model.FeedEntry.__gt__","text":"Assert if an object is greater than us. Parameters: Name Type Description Default other FeedEntry FeedEntry to compare. required Exceptions: Type Description TypeError If the id type of the objects is not compatible. Source code in mkdocs_newsletter/model.py def __gt__ ( self , other : \"FeedEntry\" ) -> bool : \"\"\"Assert if an object is greater than us. Args: other: FeedEntry to compare. Raises: TypeError: If the id type of the objects is not compatible. \"\"\" return self . published > other . published","title":"__gt__()"},{"location":"reference/#mkdocs_newsletter.model.FeedEntry.__lt__","text":"Assert if an object is smaller than us. Parameters: Name Type Description Default other FeedEntry FeedEntry to compare. required Exceptions: Type Description TypeError If the id type of the objects is not compatible. Source code in mkdocs_newsletter/model.py def __lt__ ( self , other : \"FeedEntry\" ) -> bool : \"\"\"Assert if an object is smaller than us. Args: other: FeedEntry to compare. Raises: TypeError: If the id type of the objects is not compatible. \"\"\" return self . published < other . published","title":"__lt__()"},{"location":"reference/#mkdocs_newsletter.model.LastNewsletter","text":"Represents the last newsletter for each feed type.","title":"LastNewsletter"},{"location":"reference/#mkdocs_newsletter.model.LastNewsletter.min","text":"Return the smallest date of all the feeds. Source code in mkdocs_newsletter/model.py def min ( self ) -> Optional [ datetime ]: \"\"\"Return the smallest date of all the feeds.\"\"\" try : return min ( value for key , value in self . dict () . items () if value is not None ) except ValueError : return None","title":"min()"},{"location":"reference/#mkdocs_newsletter.model.Newsletter","text":"Represents a newsletter.","title":"Newsletter"},{"location":"reference/#mkdocs_newsletter.model.Newsletter.__gt__","text":"Assert if an object is greater than us. Parameters: Name Type Description Default other Newsletter Newsletter to compare. required Exceptions: Type Description TypeError If the id type of the objects is not compatible. Source code in mkdocs_newsletter/model.py def __gt__ ( self , other : \"Newsletter\" ) -> bool : \"\"\"Assert if an object is greater than us. Args: other: Newsletter to compare. Raises: TypeError: If the id type of the objects is not compatible. \"\"\" return self . basename > other . basename","title":"__gt__()"},{"location":"reference/#mkdocs_newsletter.model.Newsletter.__lt__","text":"Assert if an object is smaller than us. Parameters: Name Type Description Default other Newsletter Newsletter to compare. required Exceptions: Type Description TypeError If the id type of the objects is not compatible. Source code in mkdocs_newsletter/model.py def __lt__ ( self , other : \"Newsletter\" ) -> bool : \"\"\"Assert if an object is smaller than us. Args: other: Newsletter to compare. Raises: TypeError: If the id type of the objects is not compatible. \"\"\" return self . basename < other . basename","title":"__lt__()"},{"location":"reference/#mkdocs_newsletter.model.Newsletter.set_attributes","text":"Set the class attributes. basename: basename of the file. type_: Set the type of the newsletter. date: Set the datetime associated to the file name. Source code in mkdocs_newsletter/model.py @root_validator ( pre = True ) @classmethod def set_attributes ( cls , values : Dict [ str , Any ]) -> Dict [ str , Any ]: \"\"\"Set the class attributes. * basename: basename of the file. * type_: Set the type of the newsletter. * date: Set the datetime associated to the file name. \"\"\" basename = os . path . splitext ( values [ \"file_\" ] . name )[ 0 ] values [ \"basename\" ] = basename if re . match ( r \"\\d {4} $\" , basename ): values [ \"type_\" ] = \"yearly\" values [ \"date\" ] = datetime ( int ( basename ), 1 , 1 , tzinfo = tz . tzlocal ()) elif re . match ( r \"\\d {4} _\\d {2} $\" , basename ): values [ \"type_\" ] = \"monthly\" year = int ( basename . split ( \"_\" )[ 0 ]) month = int ( basename . split ( \"_\" )[ 1 ]) values [ \"date\" ] = datetime ( year , month , 1 , tzinfo = tz . tzlocal ()) elif re . match ( r \"\\d {4} _w\\d {2} $\" , basename ): values [ \"type_\" ] = \"weekly\" year = int ( basename . split ( \"_\" )[ 0 ]) week = int ( basename . split ( \"w\" )[ 1 ]) first_day = datetime ( year , 1 , 1 , tzinfo = tz . tzlocal ()) values [ \"date\" ] = first_day + timedelta ( days = 7 * ( week - 1 ) - first_day . weekday () ) elif re . match ( r \"\\d {4} _\\d {2} _\\d {2} $\" , basename ): values [ \"type_\" ] = \"daily\" values [ \"date\" ] = datetime . strptime ( basename , \"%Y_%m_ %d \" ) . replace ( tzinfo = tz . tzlocal () ) return values","title":"set_attributes()"},{"location":"reference/#mkdocs_newsletter.model.Newsletters","text":"Represents the newsletters for each feed type.","title":"Newsletters"},{"location":"reference/#mkdocs_newsletter.model.Newsletters.sort","text":"Sort the newsletters. Source code in mkdocs_newsletter/model.py def sort ( self ) -> None : \"\"\"Sort the newsletters.\"\"\" self . yearly = sorted ( self . yearly , reverse = True ) self . monthly = sorted ( self . monthly , reverse = True ) self . weekly = sorted ( self . weekly , reverse = True ) self . daily = sorted ( self . daily , reverse = True )","title":"sort()"},{"location":"reference/#mkdocs_newsletter.model.NewsletterSection","text":"Represent the section of a newsletter article. Attributes: Name Type Description title str Category title order int The order in comparison with the other categories changes List[mkdocs_newsletter.model.Change] Changes to be printed in the section subsections List[mkdocs_newsletter.model.NewsletterSection] A list of subsections.","title":"NewsletterSection"},{"location":"reference/#mkdocs_newsletter.model.NewsletterSection.__gt__","text":"Assert if an object is greater than us. Parameters: Name Type Description Default other NewsletterSection NewsletterSection to compare. required Exceptions: Type Description TypeError If the id type of the objects is not compatible. Source code in mkdocs_newsletter/model.py def __gt__ ( self , other : \"NewsletterSection\" ) -> bool : \"\"\"Assert if an object is greater than us. Args: other: NewsletterSection to compare. Raises: TypeError: If the id type of the objects is not compatible. \"\"\" return self . order < other . order","title":"__gt__()"},{"location":"reference/#mkdocs_newsletter.model.NewsletterSection.__lt__","text":"Assert if an object is smaller than us. Parameters: Name Type Description Default other NewsletterSection NewsletterSection to compare. required Exceptions: Type Description TypeError If the id type of the objects is not compatible. Source code in mkdocs_newsletter/model.py def __lt__ ( self , other : \"NewsletterSection\" ) -> bool : \"\"\"Assert if an object is smaller than us. Args: other: NewsletterSection to compare. Raises: TypeError: If the id type of the objects is not compatible. \"\"\" return self . order > other . order","title":"__lt__()"},{"location":"reference/#mkdocs_newsletter.model.NewsletterType","text":"Defines the possible newsletter types.","title":"NewsletterType"},{"location":"reference/#mkdocs_newsletter.services","text":"","title":"services"},{"location":"reference/#mkdocs_newsletter.services.git","text":"Gather all the orchestration functionality required by the program to work. Classes and functions that connect the different domain model objects with the adapters and handlers to achieve the program's purpose.","title":"git"},{"location":"reference/#mkdocs_newsletter.services.git.commit_to_changes","text":"Extract the semantic changes from a commit. Parameters: Name Type Description Default commit Commit Commit to parse. required Returns: Type Description List[mkdocs_newsletter.model.Change] Source code in mkdocs_newsletter/services/git.py def commit_to_changes ( commit : Commit ) -> List [ Change ]: \"\"\"Extract the semantic changes from a commit. Args: commit: Commit to parse. Returns: changes: List of semantic changes. \"\"\" changes : List [ Change ] = [] remaining = commit . message while remaining is not None : try : change , remaining = _parse_change ( remaining , commit . authored_date ) except ValueError : return changes changes . append ( change ) return changes","title":"commit_to_changes()"},{"location":"reference/#mkdocs_newsletter.services.git.commits_to_changes","text":"Extract the semantic changes from a list of commits. Parameters: Name Type Description Default commits List[git.objects.commit.Commit] List of commits to parse. required Returns: Type Description List[mkdocs_newsletter.model.Change] Source code in mkdocs_newsletter/services/git.py def commits_to_changes ( commits : List [ Commit ]) -> List [ Change ]: \"\"\"Extract the semantic changes from a list of commits. Args: commits: List of commits to parse. Returns: changes: List of semantic changes. \"\"\" changes = [] for commit in commits : with suppress ( ValueError ): changes += commit_to_changes ( commit ) return changes","title":"commits_to_changes()"},{"location":"reference/#mkdocs_newsletter.services.git.semantic_changes","text":"Extract meaningful changes from a git repository. Parameters: Name Type Description Default repo Repo Git repository to analyze. required Returns: Type Description List[mkdocs_newsletter.model.Change] Source code in mkdocs_newsletter/services/git.py def semantic_changes ( repo : Repo , min_date : Optional [ datetime . datetime ] = None ) -> List [ Change ]: \"\"\"Extract meaningful changes from a git repository. Args: repo: Git repository to analyze. Returns: changes: List of Change objects. \"\"\" now = datetime . datetime . now ( tz = tz . tzlocal ()) if min_date is None : min_date = datetime . datetime ( 1800 , 1 , 1 , tzinfo = tz . tzlocal ()) commits = [ commit for commit in repo . iter_commits ( rev = repo . head . reference ) if commit . authored_datetime < now and commit . authored_datetime > min_date ] return commits_to_changes ( commits )","title":"semantic_changes()"},{"location":"reference/#mkdocs_newsletter.services.nav","text":"Gather services to create the newsletters MkDocs nav section.","title":"nav"},{"location":"reference/#mkdocs_newsletter.services.nav.build_nav","text":"Build the navigation section of the newsletters. Parameters: Name Type Description Default config Config MkDocs configuration object. required newsletter_dir str Directory containing the newsletter articles. required Returns: Type Description Config The config object with the newsletters. Source code in mkdocs_newsletter/services/nav.py def build_nav ( config : Config , newsletter_dir : str ) -> Config : \"\"\"Build the navigation section of the newsletters. Args: config: MkDocs configuration object. newsletter_dir: Directory containing the newsletter articles. Returns: The config object with the newsletters. \"\"\" nav_data : Dict [ Union [ int , str ], Any ] = {} newsletter_regex = ( r \"(?P<year>\\d {4} )\" r \"(_w(?P<week_number>\\d {2} ))?\" r \"(_(?P<month>\\d {2} ))?\" r \"(_(?P<day>\\d {2} ))?.md\" ) for file_ in os . scandir ( newsletter_dir ): file_path = f \"newsletter/ { file_ . name } \" match = re . match ( newsletter_regex , file_ . name ) if match is None : if file_ . name == \"0_newsletter_index.md\" : nav_data [ \"index\" ] = file_path continue year_match = match . group ( \"year\" ) week_match = match . group ( \"week_number\" ) month_match = match . group ( \"month\" ) day_match = match . group ( \"day\" ) if year_match is not None : year = int ( year_match ) nav_data . setdefault ( year , {}) if month_match is not None : month = int ( month_match ) nav_data [ year ] . setdefault ( month , {}) if day_match is not None : day = int ( day_match ) week = datetime . datetime ( year , month , day ) . isocalendar ()[ 1 ] nav_data [ year ][ month ] . setdefault ( week , {}) nav_data [ year ][ month ][ week ][ day ] = file_path else : nav_data [ year ][ month ][ \"index\" ] = file_path elif week_match is not None : week = int ( week_match ) month = datetime . datetime . strptime ( f \" { year }{ week } -1\" , \"%Y%W-%w\" ) . month nav_data [ year ] . setdefault ( month , {}) nav_data [ year ][ month ] . setdefault ( week , {}) nav_data [ year ][ month ][ week ][ \"index\" ] = file_path else : nav_data [ year ][ \"index\" ] = file_path return _nav_data_to_nav ( nav_data , config )","title":"build_nav()"},{"location":"reference/#mkdocs_newsletter.services.newsletter","text":"Gather services related to the management of the newsletters.","title":"newsletter"},{"location":"reference/#mkdocs_newsletter.services.newsletter.add_change_categories","text":"Add category and subcategory to each change based on their file nav position. Parameters: Name Type Description Default changes List[mkdocs_newsletter.model.Change] The list of Change objects to process. required config Config MkDocs Config object. required Returns: Type Description List[mkdocs_newsletter.model.Change] Updated list of changes. Source code in mkdocs_newsletter/services/newsletter.py def add_change_categories ( changes : List [ Change ], config : Config ) -> List [ Change ]: \"\"\"Add category and subcategory to each change based on their file nav position. Args: changes: The list of Change objects to process. config: MkDocs Config object. Returns: Updated list of changes. \"\"\" for change in changes : if change . scope is not None : scope_parts = change . scope . split ( \"#\" ) change . file_ = f \" { scope_parts [ 0 ] } .md\" if len ( scope_parts ) > 1 : change . file_subsection = \"#\" + scope_parts [ 1 ] . lower () . replace ( \" \" , \"-\" ) nav_search = config [ \"nav\" ] | grep ( change . file_ ) try : nav_path = nav_search [ \"matched_values\" ][ 0 ] except KeyError : change . category = \"Other\" change . category_order = 999 change . file_ = None change . file_subsection = None continue more_than_three_levels_regex = ( r \"root\" r \"\\[(?P<category_order>\\d+)\\]\" r \"\\['(?P<category>[\\w\\s]+)'\\]\" r \"\\[(?P<subcategory_order>\\d+)\\]\" r \"\\['(?P<subcategory>[\\w\\s]+)'\\]\" r \"(\\[(?P<other_level_order>\\d+)\\]\" r \"\\['(?P<other_level_category>[\\w\\s]+)'\\])+\" r \"\\[(?P<file_section_order>\\d+)\\]\" r \"\\['(?P<file_section>[\\w\\s]+)'\\]\" r \"(\\[(?P<is_section>\\d+)\\])?\" ) less_than_four_levels_regex = ( r \"root\" r \"\\[(?P<category_order>\\d+)\\]\" r \"\\['(?P<category>[\\w\\s]+)'\\]\" r \"(\\[(?P<subcategory_order>\\d+)\\])?\" r \"(\\['(?P<subcategory>[\\w\\s]+)'\\])?\" r \"(\\[(?P<file_section_order>\\d+)\\])?\" r \"(\\['(?P<file_section>[\\w\\s]+)'\\])?\" r \"(\\[(?P<is_section>\\d+)\\])?\" ) match = re . match ( more_than_three_levels_regex , nav_path ) if match is None : match = re . match ( less_than_four_levels_regex , nav_path ) if match is not None : change . category = match . group ( \"category\" ) change . category_order = int ( match . group ( \"category_order\" )) change . subcategory = match . group ( \"subcategory\" ) if change . subcategory is not None : change . subcategory_order = int ( match . group ( \"subcategory_order\" )) change . file_section = match . group ( \"file_section\" ) if change . file_section is not None : change . file_section_order = int ( match . group ( \"file_section_order\" )) return changes","title":"add_change_categories()"},{"location":"reference/#mkdocs_newsletter.services.newsletter.create_newsletter","text":"Build the newsletter article test from the changes. Group first by category, then by subcategory and then by file. Parameters: Name Type Description Default changes List[mkdocs_newsletter.model.Change] List of changes to publish in the article required Returns: Type Description str Article markdown text. Source code in mkdocs_newsletter/services/newsletter.py def create_newsletter ( changes : List [ Change ]) -> str : \"\"\"Build the newsletter article test from the changes. Group first by category, then by subcategory and then by file. Args: changes: List of changes to publish in the article Returns: Article markdown text. \"\"\" env = Environment ( loader = PackageLoader ( \"mkdocs_newsletter\" , \"templates\" ), autoescape = select_autoescape ([ \"html\" , \"xml\" ]), ) template = env . get_template ( \"newsletter_article.j2\" ) sections = _build_newsletter_sections ( changes ) article = template . render ( sections = sections , change_type_text = CHANGE_TYPE_TEXT ) article = re . sub ( r \"\\n\\n+\" , r \"\\n\\n\" , article ) . strip () return article","title":"create_newsletter()"},{"location":"reference/#mkdocs_newsletter.services.newsletter.create_newsletter_landing_page","text":"Create the newsletter landing page. Source code in mkdocs_newsletter/services/newsletter.py def create_newsletter_landing_page ( config : Config , repo : Repo ) -> None : \"\"\"Create the newsletter landing page.\"\"\" base_dir = repo . working_dir landing_path = os . path . join ( base_dir , \"docs/newsletter/0_newsletter_index.md\" ) if not os . path . isfile ( landing_path ): env = Environment ( loader = PackageLoader ( \"mkdocs_newsletter\" , \"templates\" ), autoescape = select_autoescape ([ \"html\" , \"xml\" ]), ) template = env . get_template ( \"newsletter_landing_page.j2\" ) landing_page = template . render ( site_url = config [ \"site_url\" ]) with open ( landing_path , \"+w\" ) as landing_file : landing_file . write ( landing_page )","title":"create_newsletter_landing_page()"},{"location":"reference/#mkdocs_newsletter.services.newsletter.create_newsletters","text":"Create the newsletter articles from the semantic changes for all feeds. Fills the newsletter article jinja2 template and creates the related File objects. Parameters: Name Type Description Default changes DigitalGardenChanges The list of Change objects to publish per feed. required repo Repo Git Repo object with the MkDocs repository. required Returns: Type Description List[str] List of file paths with the newsletter articles. Source code in mkdocs_newsletter/services/newsletter.py def create_newsletters ( changes : DigitalGardenChanges , repo : Repo ) -> List [ str ]: \"\"\"Create the newsletter articles from the semantic changes for all feeds. Fills the newsletter article jinja2 template and creates the related File objects. Args: changes: The list of Change objects to publish per feed. repo: Git Repo object with the MkDocs repository. Returns: List of file paths with the newsletter articles. \"\"\" base_dir = repo . working_dir files = ( _create_feed_articles ( changes . daily , _get_daily_newsletter_file , base_dir ) + _create_feed_articles ( changes . weekly , _get_weekly_newsletter_file , base_dir ) + _create_feed_articles ( changes . monthly , _get_monthly_newsletter_file , base_dir ) + _create_feed_articles ( changes . yearly , _get_yearly_newsletter_file , base_dir ) ) return files","title":"create_newsletters()"},{"location":"reference/#mkdocs_newsletter.services.newsletter.digital_garden_changes","text":"Extract the changes that need to be published for digital_garden repositories. For a change to be published it needs to: Be made before the first day of the year and after the last published change in the year feed. Be made before the first day of the month and after the last published change in the month feed. Be made before the last Monday and after the last published change in the week feed. day: Be made before today and after the last published change in the day feed. Parameters: Name Type Description Default changes List[mkdocs_newsletter.model.Change] The list of Change objects to publish. required last_published Optional[mkdocs_newsletter.model.LastNewsletter] last published date per feed type None Returns: Type Description DigitalGardenChanges Source code in mkdocs_newsletter/services/newsletter.py def digital_garden_changes ( changes : List [ Change ], last_published : Optional [ LastNewsletter ] = None ) -> DigitalGardenChanges : \"\"\"Extract the changes that need to be published for digital_garden repositories. For a change to be published it needs to: year: Be made before the first day of the year and after the last published change in the year feed. month: Be made before the first day of the month and after the last published change in the month feed. week: Be made before the last Monday and after the last published change in the week feed. day: Be made before today and after the last published change in the day feed. Args: changes: The list of Change objects to publish. last_published: last published date per feed type Returns: changes: Ordered changes to publish per feed. \"\"\" now = datetime . datetime . now ( tz . tzlocal ()) today = now . replace ( hour = 0 , minute = 0 , second = 0 , microsecond = 0 ) last_first_weekday = today - datetime . timedelta ( days = now . weekday ()) last_first_monthday = today . replace ( day = 1 ) last_first_yearday = today . replace ( day = 1 , month = 1 ) if last_published is None : last_published = LastNewsletter () return DigitalGardenChanges ( daily = [ change for change in changes if change . date < today and ( last_published . daily is None or change . date > last_published . daily ) and change . type_ in CHANGE_TYPE_TEXT ], weekly = [ change for change in changes if change . date < last_first_weekday and ( last_published . weekly is None or change . date > last_published . weekly ) and change . type_ in CHANGE_TYPE_TEXT ], monthly = [ change for change in changes if change . date < last_first_monthday and ( last_published . monthly is None or change . date > last_published . monthly ) and change . type_ in CHANGE_TYPE_TEXT ], yearly = [ change for change in changes if change . date < last_first_yearday and ( last_published . yearly is None or change . date > last_published . yearly ) and change . type_ in CHANGE_TYPE_TEXT ], )","title":"digital_garden_changes()"},{"location":"reference/#mkdocs_newsletter.services.newsletter.last_newsletter_changes","text":"Extract the date of the last change of the last newsletter for each feed. Parameters: Name Type Description Default newsletter_dir str Directory containing the newsletter articles. required Returns: Type Description LastNewsletter Source code in mkdocs_newsletter/services/newsletter.py def last_newsletter_changes ( newsletter_dir : str ) -> LastNewsletter : \"\"\"Extract the date of the last change of the last newsletter for each feed. Args: newsletter_dir: Directory containing the newsletter articles. Returns: last_newsletter: LastNewsletter object. \"\"\" newsletters = _list_newsletters ( newsletter_dir ) last = LastNewsletter () # Year feed: Saves the first day of the next year. with suppress ( IndexError ): last . yearly = newsletters . yearly [ 0 ] . date + relativedelta ( years = 1 ) # Month feed: Saves the first day of the next month. with suppress ( IndexError ): last_file_date = newsletters . monthly [ 0 ] . date last . monthly = datetime . datetime ( last_file_date . year + int ( last_file_date . month / 12 ), (( last_file_date . month % 12 ) + 1 ), 1 , tzinfo = tz . tzlocal (), ) # Week feed: Saves the next Monday from the week of the week number. with suppress ( IndexError ): last . weekly = newsletters . weekly [ 0 ] . date + datetime . timedelta ( days = 7 ) # Daily feed: Saves the next day. with suppress ( IndexError ): last . daily = newsletters . daily [ 0 ] . date + datetime . timedelta ( days = 1 ) return last","title":"last_newsletter_changes()"},{"location":"reference/#mkdocs_newsletter.services.rss","text":"Define the RSS management services.","title":"rss"},{"location":"reference/#mkdocs_newsletter.services.rss.build_rss_feed","text":"Create the RSS feed data from the content. Parameters: Name Type Description Default config Config MkDocs config object. required type_ str type of feed, one of: daily, weekly, monthly or yearly. required Returns: Type Description Feed Feed object with the data Source code in mkdocs_newsletter/services/rss.py def build_rss_feed ( config : Config , working_dir : str , type_ : str ) -> Feed : \"\"\"Create the RSS feed data from the content. Args: config: MkDocs config object. type_: type of feed, one of: daily, weekly, monthly or yearly. Returns: Feed object with the data \"\"\" site_url = config [ \"site_url\" ] try : logo_url : Optional [ str ] = f \" { site_url } / { config [ 'theme' ][ 'logo' ] } \" except KeyError : logo_url = None author = config . get ( \"site_author\" , None ) entries = _build_rss_entries ( config , working_dir , type_ , author ) try : published = max ( entries ) . published except ValueError : published = datetime . datetime . now () return Feed ( ttl = TTL [ type_ ], generator = f \"mkdocs-newsletter - v { __version__ } \" , title = config . get ( \"site_name\" , None ), link = site_url , rss_link = f \" { site_url } / { type_ } .xml\" , logo = logo_url , description = config . get ( \"site_description\" , None ), author = author , published = published , entries = entries , )","title":"build_rss_feed()"},{"location":"reference/#mkdocs_newsletter.services.rss.create_rss","text":"Create RSS feed with the newsletters of a period. Source code in mkdocs_newsletter/services/rss.py def create_rss ( config : Config , working_dir : str ) -> None : \"\"\"Create RSS feed with the newsletters of a period.\"\"\" feed_types = [ type_ . value for type_ in NewsletterType ] for feed_type in feed_types : feed = build_rss_feed ( config , working_dir , feed_type ) env = Environment ( loader = PackageLoader ( \"mkdocs_newsletter\" , \"templates\" ), autoescape = select_autoescape ([ \"html\" , \"xml\" ]), ) template = env . get_template ( \"rss.xml.j2\" ) feed_path = os . path . join ( config [ \"site_dir\" ], f \" { feed_type } .xml\" ) feed_content = template . render ( feed = feed ) with open ( feed_path , \"+w\" ) as feed_file : feed_file . write ( feed_content )","title":"create_rss()"},{"location":"reference/#mkdocs_newsletter.version","text":"Utilities to retrieve the information of the program version.","title":"version"},{"location":"reference/#mkdocs_newsletter.version.version_info","text":"Display the version of the program, python and the platform. Source code in mkdocs_newsletter/version.py def version_info () -> str : \"\"\"Display the version of the program, python and the platform.\"\"\" info = { \"mkdocs_newsletter version\" : __version__ , \"python version\" : sys . version . replace ( \" \\n \" , \" \" ), \"platform\" : platform . platform (), } return \" \\n \" . join ( f \" { k + ':' : >30 } { v } \" for k , v in info . items ())","title":"version_info()"},{"location":"rss_feeds/","text":"","title":"Rss feeds"},{"location":"usage/","text":"Every time you build the site, the plugin will inspect the git history and create the new newsletter articles under the docs/newsletter directory and configure the Newsletter section. The entrypoints for the authors are: Writing the commit messages . Manually changing the created newsletter articles : to fix errors. Commit message guidelines \u00b6 The plugin assumes that you're using the Angular semantic versioning format to create the commits. Adapted to a documentation repository such as the digital gardens , the structure would be: {type_of_change}({file_changed}): {short_description} {full_description} Where: type_of_change is one of: feat : Add new content to the repository, it can be a new file or new content on an existent file. fix : Correct existing content. perf : Improve existing content. refactor : Reorder the articles content. style : Correct grammar, orthography or broken links. ci : Change the continuous integration pipelines. chore : Update the dependencies required to build the site. file_changed : Name of the changed file (without the .md extension). short_description : A succinct description of the change. It doesn't need to start with a capitalize letter nor end with a dot. full_description : A summary of the added changes. For example: feat(adr): introduce the Architecture Decision Records [ADR](https://github.com/joelparkerhenderson/architecture_decision_record) are short text documents that captures an important architectural decision made along with its context and consequences. Only changes of type feat , fix , perf or refactor will be added to the newsletter. The reader is not interested in the others. Multiple changes in the same commit \u00b6 When growing digital gardens , it's normal to do many small changes on different files. Making a commit for each of them is cumbersome and can break your writing flow. That's why the plugin is able to parse different changes from the same commit. For example: feat(pexpect): introduce the pexpect python library A pure Python module for spawning child applications; controlling them; and responding to expected patterns in their output. Pexpect works like Don Libes\u2019 Expect. Pexpect allows your script to spawn a child application and control it as if a human were typing commands. style(prompt_toolkit): correct links and indentations fix(python_snippets): explain how to show the message in custom exceptions feat(python_snippets): explain how to import a module or object from within a python program Link specific parts of the articles \u00b6 You can specify the section of the article where the change has been made by appending the anchor to the file changed. For example: perf(prometheus_installation#upgrading-notes): Add upgrading notes from 10.x -> 11.1.7 The format of the anchor can be Markdown's default or you can use the user friendly one with caps and spaces perf(prometheus_installation#Upgrading notes) . Rich full description content \u00b6 The full_description content will be processed by MkDocs, that means that all it's features applies, such as autolinking or admonitions. perf(prometheus_installation): Add upgrading notes from 10.x -> 11.1.7 !!! warning \"Don't upgrade to 12.x if you're still using Helm 2.\" [ Helm ]( helm.md#version-2 ) is deprecated and you should migrate to v3. Manual newsletter changes \u00b6 To change the contents of the newsletters directly edit the files under docs/newsletters .","title":"Usage"},{"location":"usage/#commit-message-guidelines","text":"The plugin assumes that you're using the Angular semantic versioning format to create the commits. Adapted to a documentation repository such as the digital gardens , the structure would be: {type_of_change}({file_changed}): {short_description} {full_description} Where: type_of_change is one of: feat : Add new content to the repository, it can be a new file or new content on an existent file. fix : Correct existing content. perf : Improve existing content. refactor : Reorder the articles content. style : Correct grammar, orthography or broken links. ci : Change the continuous integration pipelines. chore : Update the dependencies required to build the site. file_changed : Name of the changed file (without the .md extension). short_description : A succinct description of the change. It doesn't need to start with a capitalize letter nor end with a dot. full_description : A summary of the added changes. For example: feat(adr): introduce the Architecture Decision Records [ADR](https://github.com/joelparkerhenderson/architecture_decision_record) are short text documents that captures an important architectural decision made along with its context and consequences. Only changes of type feat , fix , perf or refactor will be added to the newsletter. The reader is not interested in the others.","title":"Commit message guidelines"},{"location":"usage/#multiple-changes-in-the-same-commit","text":"When growing digital gardens , it's normal to do many small changes on different files. Making a commit for each of them is cumbersome and can break your writing flow. That's why the plugin is able to parse different changes from the same commit. For example: feat(pexpect): introduce the pexpect python library A pure Python module for spawning child applications; controlling them; and responding to expected patterns in their output. Pexpect works like Don Libes\u2019 Expect. Pexpect allows your script to spawn a child application and control it as if a human were typing commands. style(prompt_toolkit): correct links and indentations fix(python_snippets): explain how to show the message in custom exceptions feat(python_snippets): explain how to import a module or object from within a python program","title":"Multiple changes in the same commit"},{"location":"usage/#link-specific-parts-of-the-articles","text":"You can specify the section of the article where the change has been made by appending the anchor to the file changed. For example: perf(prometheus_installation#upgrading-notes): Add upgrading notes from 10.x -> 11.1.7 The format of the anchor can be Markdown's default or you can use the user friendly one with caps and spaces perf(prometheus_installation#Upgrading notes) .","title":"Link specific parts of the articles"},{"location":"usage/#rich-full-description-content","text":"The full_description content will be processed by MkDocs, that means that all it's features applies, such as autolinking or admonitions. perf(prometheus_installation): Add upgrading notes from 10.x -> 11.1.7 !!! warning \"Don't upgrade to 12.x if you're still using Helm 2.\" [ Helm ]( helm.md#version-2 ) is deprecated and you should migrate to v3.","title":"Rich full description content"},{"location":"usage/#manual-newsletter-changes","text":"To change the contents of the newsletters directly edit the files under docs/newsletters .","title":"Manual newsletter changes"},{"location":"adr/001-initial_approach/","text":"Status \u00b6 Accepted Extended by: 002 Context \u00b6 Gathering knowledge in my blue book has been a pleasant experience in the last year. The only drawback of the system is that I don't know a user friendly way to inform the readers of content updates or fixes, such as an RSS feed of/and a periodic newsletter. That means that when the user stumbles upon the site, they spend a limited amount of time reading it, and then forgets of it's existence. If they see themselves back to the site, they don't know what have they've already seen, which can make them feel lost or loosing their time. Even if they clone the repository, they need to go through the log to see the changes, which is awful. And that means that all the efforts we put into growing our digital gardens or our software applications is not appreciated all that it should be. If we created a way to show them what has changed in a friendly way we will: Make their experience more pleasant. Make them more prone to visit the site again. We must be careful though, we don't want to worsen the bombardment of information we are suffering. We need to notify the user in a respectful way by sending them only relevant content at the pace they choose to. For the idea to work, we'd first need that the authors want to use the solution. So we need to build a system that doesn't increase the mental load or effort to a point that makes it unappealing. That can be done by: Automating all the processes that we can. Reducing to the minimum the author entrypoints. Making it easy for them to introduce the manual data that we need. Reduce the deviation from their current workflow. Proposals \u00b6 To solve the issue we need to decide: Which updates are relevant. How to reduce the number of notifications the user receives. Which notification channels we want to support. Which programming solution to use. How to extract relevant changes \u00b6 Manual processing \u00b6 At the time of building the update, we could manually review all the changes done since the last update and store that information in a programmatically processable way. The downside is that we'll need to spend a relative big amount of time to review content written in the past. I found myself skipping these batch processing tasks in the past, as my brain sees them as dreadful, long and heavy. Use semantic versioning in git commit messages \u00b6 To give semantic meaning to the changes introduced in the repository, we can use the semantic versioning principles to classify and describe each change in a way that can be programmatically decide if it's worth publishing. The idea is to create commits following a specific format that describes what kind of change you're making. I've been following this practice for a while with the following personal commit convention: {type_of_change}({file_changed}): {short_description} {full_description} Where: type_of_change is one of: feat : Add new content to the repository, it can be a new file or new content on an existent file. fix : Correct existing content. style : Correct grammar, orthography or broken links. ci : Change the continuous integration pipelines. chore : Update the python dependencies required to build the site. file_changed : name of the file changed (without the .md extension). short_description : A succinct description of the change. It doesn't need to start with a capitalize letter nor end with a dot. full_description : A summary of the added changes. For example: a single feat commit or a multientry commit With this method the responsibility of giving meaning to the changes is shared in time, which makes the task more appealing and less heavy. Additionally, with the IDE support, creating the commit messages is easier as you can copy and paste or autocomplete from the changes themselves. How to reduce the number of notifications \u00b6 There are cases where the user is still spammed even if we select the relevant changes. We can copy the solution adopted by the system's monitorization solutions, which is to group the changes to reduce the notifications. We should present different levels of aggregation, so they can receive daily, weekly or monthly notifications. Which notification channels we want to support \u00b6 Different users use different tools to get updates on what's going in the world. We can expose the updates through: An article in the documentation site. RSS. Email newsletter. API. Reddit. Hackernews. GNUsocial. Twitter. XMPP/Jabber Telegram The article in the documentation makes sense because it can be the landing page for the rest of channels, which can trigger further page views. Most of the people around me, whom I want to share my updates use RSS, which is an awesome protocol that is sadly being replaced by Twitter like webs, and we don't want that to happen. I feel that only \"technical\" users use this technology though. Everyone has an email, and sending mails through Python is easy, so it can be the easiest path to reach the global public. For the more technical ones, extracting the data from an API can help gluing together other functionalities. It could help if people want to extend the functionality that we give, for example by creating more specific RSS feeds based on categories. As we have a static site, it will only support GET methods, and we will already publish all the information in RSS format, which is parseable by programs, so adding another enpoint that exposes the same data in json format doesn't make much sense. I haven't used Reddit or Hackernews enough to know if it makes sense either this channel. I think GNUsocial and Twitter are wrongly being used to replace RSS, so it won't be a priority. A similar argument applies instant message solutions like XMPP or Telegram. Which programming solution to use \u00b6 To create the functionality, we'll need to: Semantic versioning information given by the user in the commit messages since the last change. Link the files mentioned in the commit messages to actual working links. The processing can be done through: A mkdocs plugin so it creates it at build time. It can be inspired by: mkdocs-new-features-notifier mkdocs_blog mkdocs_latest_release_plugin An existent external command line tool such as python-semantic-release and commitizen bump . A complete new external command line tool. An hybrid between both solutions, like mike . Developing a mkdocs plugin \u00b6 The advantages are: It will be easier for people to use, as it already exists a widely used plugin system in MkDocs. It will be easier for us too, as the plugin system gives a lot of information on the articles, so making working links should be easy. The disadvantages are that we'll need to: Assume that the user is not meant to manually trigger the updates creation. They will need to use a periodic automatic process similar to the one that generates the website. Decision \u00b6 We will develop a Mkdocs plugin that creates MkDocs articles whose content: Contains only relevant updates, deduced by the commit messages of the repository. Updates are grouped to reduce the user notifications . Is exposed to the user with different levels of aggregation, such as: real time, daily, weekly, monthly or yearly. Is exposed to the user through: Articles in the same MkDocs site. RSS feeds. Email newsletters. Consequences \u00b6 The user will be able to be kept updated of the relevant MkDocs site changes at the pace they desire. That will: Make their browsing experience more pleasant. Make them more prone to visit the site again. For the authors it will mean that they need to: Spend more time and thought writing the commit messages. Be tied to the solution we can give them, or contribute the desired changes. Debug possible errors produced by the increase of complexity of the system. For us it will mean that we'll need to: Build and maintain the logic and code for: Extracting and grouping the relevant updates. Sending the notifications. Keep the system updated. React to security vulnerabilities. React to issues and pull requests.","title":"001: High level problem analysis"},{"location":"adr/001-initial_approach/#status","text":"Accepted Extended by: 002","title":"Status"},{"location":"adr/001-initial_approach/#context","text":"Gathering knowledge in my blue book has been a pleasant experience in the last year. The only drawback of the system is that I don't know a user friendly way to inform the readers of content updates or fixes, such as an RSS feed of/and a periodic newsletter. That means that when the user stumbles upon the site, they spend a limited amount of time reading it, and then forgets of it's existence. If they see themselves back to the site, they don't know what have they've already seen, which can make them feel lost or loosing their time. Even if they clone the repository, they need to go through the log to see the changes, which is awful. And that means that all the efforts we put into growing our digital gardens or our software applications is not appreciated all that it should be. If we created a way to show them what has changed in a friendly way we will: Make their experience more pleasant. Make them more prone to visit the site again. We must be careful though, we don't want to worsen the bombardment of information we are suffering. We need to notify the user in a respectful way by sending them only relevant content at the pace they choose to. For the idea to work, we'd first need that the authors want to use the solution. So we need to build a system that doesn't increase the mental load or effort to a point that makes it unappealing. That can be done by: Automating all the processes that we can. Reducing to the minimum the author entrypoints. Making it easy for them to introduce the manual data that we need. Reduce the deviation from their current workflow.","title":"Context"},{"location":"adr/001-initial_approach/#proposals","text":"To solve the issue we need to decide: Which updates are relevant. How to reduce the number of notifications the user receives. Which notification channels we want to support. Which programming solution to use.","title":"Proposals"},{"location":"adr/001-initial_approach/#how-to-extract-relevant-changes","text":"","title":"How to extract relevant changes"},{"location":"adr/001-initial_approach/#manual-processing","text":"At the time of building the update, we could manually review all the changes done since the last update and store that information in a programmatically processable way. The downside is that we'll need to spend a relative big amount of time to review content written in the past. I found myself skipping these batch processing tasks in the past, as my brain sees them as dreadful, long and heavy.","title":"Manual processing"},{"location":"adr/001-initial_approach/#use-semantic-versioning-in-git-commit-messages","text":"To give semantic meaning to the changes introduced in the repository, we can use the semantic versioning principles to classify and describe each change in a way that can be programmatically decide if it's worth publishing. The idea is to create commits following a specific format that describes what kind of change you're making. I've been following this practice for a while with the following personal commit convention: {type_of_change}({file_changed}): {short_description} {full_description} Where: type_of_change is one of: feat : Add new content to the repository, it can be a new file or new content on an existent file. fix : Correct existing content. style : Correct grammar, orthography or broken links. ci : Change the continuous integration pipelines. chore : Update the python dependencies required to build the site. file_changed : name of the file changed (without the .md extension). short_description : A succinct description of the change. It doesn't need to start with a capitalize letter nor end with a dot. full_description : A summary of the added changes. For example: a single feat commit or a multientry commit With this method the responsibility of giving meaning to the changes is shared in time, which makes the task more appealing and less heavy. Additionally, with the IDE support, creating the commit messages is easier as you can copy and paste or autocomplete from the changes themselves.","title":"Use semantic versioning in git commit messages"},{"location":"adr/001-initial_approach/#how-to-reduce-the-number-of-notifications","text":"There are cases where the user is still spammed even if we select the relevant changes. We can copy the solution adopted by the system's monitorization solutions, which is to group the changes to reduce the notifications. We should present different levels of aggregation, so they can receive daily, weekly or monthly notifications.","title":"How to reduce the number of notifications"},{"location":"adr/001-initial_approach/#which-notification-channels-we-want-to-support","text":"Different users use different tools to get updates on what's going in the world. We can expose the updates through: An article in the documentation site. RSS. Email newsletter. API. Reddit. Hackernews. GNUsocial. Twitter. XMPP/Jabber Telegram The article in the documentation makes sense because it can be the landing page for the rest of channels, which can trigger further page views. Most of the people around me, whom I want to share my updates use RSS, which is an awesome protocol that is sadly being replaced by Twitter like webs, and we don't want that to happen. I feel that only \"technical\" users use this technology though. Everyone has an email, and sending mails through Python is easy, so it can be the easiest path to reach the global public. For the more technical ones, extracting the data from an API can help gluing together other functionalities. It could help if people want to extend the functionality that we give, for example by creating more specific RSS feeds based on categories. As we have a static site, it will only support GET methods, and we will already publish all the information in RSS format, which is parseable by programs, so adding another enpoint that exposes the same data in json format doesn't make much sense. I haven't used Reddit or Hackernews enough to know if it makes sense either this channel. I think GNUsocial and Twitter are wrongly being used to replace RSS, so it won't be a priority. A similar argument applies instant message solutions like XMPP or Telegram.","title":"Which notification channels we want to support"},{"location":"adr/001-initial_approach/#which-programming-solution-to-use","text":"To create the functionality, we'll need to: Semantic versioning information given by the user in the commit messages since the last change. Link the files mentioned in the commit messages to actual working links. The processing can be done through: A mkdocs plugin so it creates it at build time. It can be inspired by: mkdocs-new-features-notifier mkdocs_blog mkdocs_latest_release_plugin An existent external command line tool such as python-semantic-release and commitizen bump . A complete new external command line tool. An hybrid between both solutions, like mike .","title":"Which programming solution to use"},{"location":"adr/001-initial_approach/#developing-a-mkdocs-plugin","text":"The advantages are: It will be easier for people to use, as it already exists a widely used plugin system in MkDocs. It will be easier for us too, as the plugin system gives a lot of information on the articles, so making working links should be easy. The disadvantages are that we'll need to: Assume that the user is not meant to manually trigger the updates creation. They will need to use a periodic automatic process similar to the one that generates the website.","title":"Developing a mkdocs plugin"},{"location":"adr/001-initial_approach/#decision","text":"We will develop a Mkdocs plugin that creates MkDocs articles whose content: Contains only relevant updates, deduced by the commit messages of the repository. Updates are grouped to reduce the user notifications . Is exposed to the user with different levels of aggregation, such as: real time, daily, weekly, monthly or yearly. Is exposed to the user through: Articles in the same MkDocs site. RSS feeds. Email newsletters.","title":"Decision"},{"location":"adr/001-initial_approach/#consequences","text":"The user will be able to be kept updated of the relevant MkDocs site changes at the pace they desire. That will: Make their browsing experience more pleasant. Make them more prone to visit the site again. For the authors it will mean that they need to: Spend more time and thought writing the commit messages. Be tied to the solution we can give them, or contribute the desired changes. Debug possible errors produced by the increase of complexity of the system. For us it will mean that we'll need to: Build and maintain the logic and code for: Extracting and grouping the relevant updates. Sending the notifications. Keep the system updated. React to security vulnerabilities. React to issues and pull requests.","title":"Consequences"},{"location":"adr/002-initial_plugin_design/","text":"Status \u00b6 Accepted Based on: 001 Extended by: 003 , 004 , and 005 . Context \u00b6 Taking 001 as a starting point, we want to define the processes that the mkdocs plugin need to have to fulfill the desired requirements. Proposals \u00b6 The plugin will consist on the following phases: Select the changes that need to be recorded . Create the newsletter articles from those changes . Build the MkDocs nav with the newsletter articles Decide which changes need to be notified Send the notifications: Update the RSS Send the email. Decision \u00b6 Implement the only proposal. Consequences \u00b6","title":"002: Initial mkdocs plugin design"},{"location":"adr/002-initial_plugin_design/#status","text":"Accepted Based on: 001 Extended by: 003 , 004 , and 005 .","title":"Status"},{"location":"adr/002-initial_plugin_design/#context","text":"Taking 001 as a starting point, we want to define the processes that the mkdocs plugin need to have to fulfill the desired requirements.","title":"Context"},{"location":"adr/002-initial_plugin_design/#proposals","text":"The plugin will consist on the following phases: Select the changes that need to be recorded . Create the newsletter articles from those changes . Build the MkDocs nav with the newsletter articles Decide which changes need to be notified Send the notifications: Update the RSS Send the email.","title":"Proposals"},{"location":"adr/002-initial_plugin_design/#decision","text":"Implement the only proposal.","title":"Decision"},{"location":"adr/002-initial_plugin_design/#consequences","text":"","title":"Consequences"},{"location":"adr/003-select_the_changes_to_record/","text":"Status \u00b6 Accepted. Based on: 002 , 004 Context \u00b6 We need to create some logic that reads from the git log to: Extract the last published changes . To update the articles and feeds, we need to know which changes have been already published, so subsequent mkdocs build processes don't repeat work already done. Parse the commit messages to extract the semantic versioning information from them. The message must follow the angular commit guidelines with the exception that we'll allow many changes in the same commit message. Extract file context from the MkDocs nav Get the changes that need to be added to the newsletter articles . We've defined different levels of aggregation for the user to choose how often they want to be notified: daily, weekly, monthly or yearly. Proposals \u00b6 Extract the last published changes \u00b6 We can: Add meaningful tags to the repository : If we create a tag last_weekly on the commit of the last published changed for the weekly feed, then we can add to the changes to publish only those posterior to that commit. Save the last commit ids in a file in the repo : If we create a hidden .last_published.json with the last commit id of each feed type, we can add to the feeds only the changes that are posterior to those commits. Save the last commit ids in the mkdocs.yaml file : We can save the last commit ids in the configuration section of the plugin in the mkdocs.yaml file. Deduce the last published date from existent articles : We already have this information in the existent articles. All we would need to do is analyze the files in the on_files and deduce the last content publication. Add meaningful tags to the repository \u00b6 Using tags has the advantage that we could reuse the Repo object to extract the information, which we already use in the services that process the changes. The disadvantage is that we'll pollute the git repository with tags that may not be interesting to the user. In the digital garden case, it's not a problem, but it can be in the changelog one. Save the last commit ids in a file in the repo \u00b6 Storing the commit ids in a hidden json file has the advantage that we don't pollute the git repository, we can use the json export and import functionality of pydantic. The disadvantage is that we'll create an additional file in the repository. cruft uses this method. Save the last commit ids in the mkdocs.yaml file \u00b6 Storing the commit ids in the mkdocs.yaml file has the advantage that it doesn't pollute either the git repository nor the project directory. The disadvantage is that it pollutes the mkdocs configuration file. Deduce the last published date from existent articles \u00b6 Using the existent articles has these advantages: It doesn't pollute either the git repository, nor the project directory nor the mkdocs configuration file. We can fetch the last published date per feed before parsing the commits, so instead of analyzing the whole history, we can go from the newest till the desired dates, making the algorithm more efficient.. We don't overwrite the existent articles, so if the user makes changes on them, they are respected. The disadvantage is that we need to code the extraction of that dates from the files collection, but it should not be difficult. Assuming that we have the existent articles organized following 004 , we can create a function that reads the files attribute from the on_files event and deduces the date of the last change of the last newsletter article for each feed. Parse the commit messages \u00b6 We can: Use the python-semantic-release library. Use the commitizen library. Write our own parser. After reviewing the existent libraries, I've found that python-semantic-release exposes the parsed data in a friendlier way. The only drawback is that it uses NamedTuples for the objects that hold the parsed data, so if we want to change one, we need to create a new one from the old. Using an existent library, if it's well maintained, is always better than writing your own. Extract file context from the MkDocs nav \u00b6 For each file that contains changes, we need to deduce the relative position in the nav against the rest of articles. This is necessary so we're able to group changes together by category, subcategory and file later in the newsletter creation . We can use the Deepdiff to locate the file in the nav tree, and then extract the context information from the path. Get the changes that need to be added to the newsletter articles \u00b6 For a change to be added to each feed it needs to: year: Be made before the first day of the year and after the last published change in the year feed. month: Be made before the first day of the month and after the last published change in the month feed. week: Be made before the last Monday and after the last published change in the week feed. day: Be made before today and after the last published change in the day feed. Decision \u00b6 We will: Run this phase in the on_files MkDocs event to be able to have the list of articles to process. Deduce the last published date from existent articles as it's the cleanest solution in terms of repository pollution. Extract the last published dates before we parse the commit messages. Process only the commits that are posterior to those dates. Use python-semantic-release library to parse the commit messages. Extract file context from the MkDocs nav Get the changes that need to be added to the newsletter articles with the different feeds. Consequences \u00b6 We don't have to write the parsing logic, it's maintained by the community and it needs few changes to fulfill our needs. Advantages: We'll know between builds which changes have been already published. We'll reduce the amount of commits that we parse, thus making the process more efficient. We wont overwrite manual user changes in the published articles. Disadvantages: We need to code and maintain the extraction of last published date from the list of repository files.","title":"003: Select the changes to record"},{"location":"adr/003-select_the_changes_to_record/#status","text":"Accepted. Based on: 002 , 004","title":"Status"},{"location":"adr/003-select_the_changes_to_record/#context","text":"We need to create some logic that reads from the git log to: Extract the last published changes . To update the articles and feeds, we need to know which changes have been already published, so subsequent mkdocs build processes don't repeat work already done. Parse the commit messages to extract the semantic versioning information from them. The message must follow the angular commit guidelines with the exception that we'll allow many changes in the same commit message. Extract file context from the MkDocs nav Get the changes that need to be added to the newsletter articles . We've defined different levels of aggregation for the user to choose how often they want to be notified: daily, weekly, monthly or yearly.","title":"Context"},{"location":"adr/003-select_the_changes_to_record/#proposals","text":"","title":"Proposals"},{"location":"adr/003-select_the_changes_to_record/#extract-the-last-published-changes","text":"We can: Add meaningful tags to the repository : If we create a tag last_weekly on the commit of the last published changed for the weekly feed, then we can add to the changes to publish only those posterior to that commit. Save the last commit ids in a file in the repo : If we create a hidden .last_published.json with the last commit id of each feed type, we can add to the feeds only the changes that are posterior to those commits. Save the last commit ids in the mkdocs.yaml file : We can save the last commit ids in the configuration section of the plugin in the mkdocs.yaml file. Deduce the last published date from existent articles : We already have this information in the existent articles. All we would need to do is analyze the files in the on_files and deduce the last content publication.","title":"Extract the last published changes"},{"location":"adr/003-select_the_changes_to_record/#add-meaningful-tags-to-the-repository","text":"Using tags has the advantage that we could reuse the Repo object to extract the information, which we already use in the services that process the changes. The disadvantage is that we'll pollute the git repository with tags that may not be interesting to the user. In the digital garden case, it's not a problem, but it can be in the changelog one.","title":"Add meaningful tags to the repository"},{"location":"adr/003-select_the_changes_to_record/#save-the-last-commit-ids-in-a-file-in-the-repo","text":"Storing the commit ids in a hidden json file has the advantage that we don't pollute the git repository, we can use the json export and import functionality of pydantic. The disadvantage is that we'll create an additional file in the repository. cruft uses this method.","title":"Save the last commit ids in a file in the repo"},{"location":"adr/003-select_the_changes_to_record/#save-the-last-commit-ids-in-the-mkdocsyaml-file","text":"Storing the commit ids in the mkdocs.yaml file has the advantage that it doesn't pollute either the git repository nor the project directory. The disadvantage is that it pollutes the mkdocs configuration file.","title":"Save the last commit ids in the mkdocs.yaml file"},{"location":"adr/003-select_the_changes_to_record/#deduce-the-last-published-date-from-existent-articles","text":"Using the existent articles has these advantages: It doesn't pollute either the git repository, nor the project directory nor the mkdocs configuration file. We can fetch the last published date per feed before parsing the commits, so instead of analyzing the whole history, we can go from the newest till the desired dates, making the algorithm more efficient.. We don't overwrite the existent articles, so if the user makes changes on them, they are respected. The disadvantage is that we need to code the extraction of that dates from the files collection, but it should not be difficult. Assuming that we have the existent articles organized following 004 , we can create a function that reads the files attribute from the on_files event and deduces the date of the last change of the last newsletter article for each feed.","title":"Deduce the last published date from existent articles"},{"location":"adr/003-select_the_changes_to_record/#parse-the-commit-messages","text":"We can: Use the python-semantic-release library. Use the commitizen library. Write our own parser. After reviewing the existent libraries, I've found that python-semantic-release exposes the parsed data in a friendlier way. The only drawback is that it uses NamedTuples for the objects that hold the parsed data, so if we want to change one, we need to create a new one from the old. Using an existent library, if it's well maintained, is always better than writing your own.","title":"Parse the commit messages"},{"location":"adr/003-select_the_changes_to_record/#extract-file-context-from-the-mkdocs-nav","text":"For each file that contains changes, we need to deduce the relative position in the nav against the rest of articles. This is necessary so we're able to group changes together by category, subcategory and file later in the newsletter creation . We can use the Deepdiff to locate the file in the nav tree, and then extract the context information from the path.","title":"Extract file context from the MkDocs nav"},{"location":"adr/003-select_the_changes_to_record/#get-the-changes-that-need-to-be-added-to-the-newsletter-articles","text":"For a change to be added to each feed it needs to: year: Be made before the first day of the year and after the last published change in the year feed. month: Be made before the first day of the month and after the last published change in the month feed. week: Be made before the last Monday and after the last published change in the week feed. day: Be made before today and after the last published change in the day feed.","title":"Get the changes that need to be added to the newsletter articles"},{"location":"adr/003-select_the_changes_to_record/#decision","text":"We will: Run this phase in the on_files MkDocs event to be able to have the list of articles to process. Deduce the last published date from existent articles as it's the cleanest solution in terms of repository pollution. Extract the last published dates before we parse the commit messages. Process only the commits that are posterior to those dates. Use python-semantic-release library to parse the commit messages. Extract file context from the MkDocs nav Get the changes that need to be added to the newsletter articles with the different feeds.","title":"Decision"},{"location":"adr/003-select_the_changes_to_record/#consequences","text":"We don't have to write the parsing logic, it's maintained by the community and it needs few changes to fulfill our needs. Advantages: We'll know between builds which changes have been already published. We'll reduce the amount of commits that we parse, thus making the process more efficient. We wont overwrite manual user changes in the published articles. Disadvantages: We need to code and maintain the extraction of last published date from the list of repository files.","title":"Consequences"},{"location":"adr/004-article_newsletter_structure/","text":"Status \u00b6 Accepted Context \u00b6 We want to define how to organize the articles that contain the updates as a section of the MkDocs site in a way that: It's easy and pleasant for the user to navigate. It's easy for us to parse programmatically. Proposals \u00b6 The frequency of updates can be weekly or monthly, structured in a mkdocs nav similar to: Newsletters : - newsletter/0_newsletter_index.md - 2020 : - newsletter/2020.md - February of 2020 : - newsletter/2020_01.md - 6th Week of 2020 : - newsletter/2020_w06.md - 11st February 2020 : newsletter/2020_01_01.md - 5th Week of 2020 : - newsletter/2020_w05.md - 1st February 2020 : newsletter/2020_01_01.md - January of 2020 : - newsletter/2020_01.md - 1st Week of 2020 : - newsletter/2020_w01.md - 3rd January 2020 : newsletter/2020_01_03.md - 1st January 2020 : newsletter/2020_01_01.md Where: 0_newsletter_index.md : Is the landing page of the newsletters. It's prepended with 0_ so it shows the first item when you do ls in the directory. It will be created from a template the first time you run it, then you can change the file to fit your liking. 2020.md : Is an automatic year summary done at the end of the year. 2020_01.md : Is an automatic month summary for the monthly rss done at the end of the month joining the changes of the month weeks. 2020_w01.md : Is an automatic week summary for the weekly rss done at the end of the week joining the changes of the week days. 2020_01_01.md : Is an automatic day summary for the daily rss. My first idea as a MkDocs user, and newborn plugin developer was to add the navigation items to the nav key in the config object, as it's more easy to add items to a dictionary I'm used to work with than to dive into the code and understand how MkDocs creates the navigation. As I understood from the docs, the files should be created in the on_files event. the problem with this approach is that the only event that allows you to change the config is the on_config event, which is before the on_files one, so you can't build the navigation this way after you've created the files. Next idea was to add the items in the on_nav event, that means creating yourself the Section , Pages , SectionPages or Link objects and append them to the nav.items . The problem is that MkDocs initializes and processes the Navigation object in the get_navigation function. If you want to add items with a plugin in the on_nav event, you need to manually run all the post processing functions such as building the pages attribute, by running the _get_by_type , _add_previous_and_next_links or _add_parent_links yourself. Additionally, when building the site you'll get the The following pages exist in the docs directory, but are not included in the \"nav\" configuration error, because that check is done before all plugins change the navigation in the on_nav object. The last approach is to build the files and tweak the navigation in the on_config event. This approach has the next advantages: You need less knowledge of how MkDocs works. You don't need to create the File or Files objects. You don't need to create the Page , Section , SectionPage objects. More robust as you rely on existent MkDocs functionality. We need to define: How to translate from a list of newsletter file names to the nav structure. Whether to build the nav from scratch on each build or reuse the done job. How to translate from a list of newsletter file names to the nav structure \u00b6 The complex part here is how to get the ordering of the elements in the nav right. We could: Create a nav_data dictionary with the following structure: { year : { 'index' : year.md , month_number : { 'index' : year_month.md , week_number : { 'index' : year_wweek_number.md , day : year_month_day.md } } } } And then translate the nav_data to the actual nav contents. Build the nav from scratch or reuse previous run's nav \u00b6 We can either build the whole newsletter nav each time we build the site or we can store the nav somewhere and only append the new articles. The second option is more efficient in terms of energy, I don't want to store in the mkdocs.yml file as the newsletter nav can grow fast, making the file dirty. Another possibility is to save the nav in docs/newsletter/.newsletter_nav.yaml . If we store the newsletter nav dictionary, it would be difficult to deduce where does the new entries fit in so that the nav is still ordered. It would make more sense to store the nav_data object, but building that object is relatively cheap, so it may not be worth even storing it. Decision \u00b6 Follow the only proposal regarding the structure, and we'll build the nav from scratch each time we build the site. Consequences \u00b6","title":"004: Article newsletter structure"},{"location":"adr/004-article_newsletter_structure/#status","text":"Accepted","title":"Status"},{"location":"adr/004-article_newsletter_structure/#context","text":"We want to define how to organize the articles that contain the updates as a section of the MkDocs site in a way that: It's easy and pleasant for the user to navigate. It's easy for us to parse programmatically.","title":"Context"},{"location":"adr/004-article_newsletter_structure/#proposals","text":"The frequency of updates can be weekly or monthly, structured in a mkdocs nav similar to: Newsletters : - newsletter/0_newsletter_index.md - 2020 : - newsletter/2020.md - February of 2020 : - newsletter/2020_01.md - 6th Week of 2020 : - newsletter/2020_w06.md - 11st February 2020 : newsletter/2020_01_01.md - 5th Week of 2020 : - newsletter/2020_w05.md - 1st February 2020 : newsletter/2020_01_01.md - January of 2020 : - newsletter/2020_01.md - 1st Week of 2020 : - newsletter/2020_w01.md - 3rd January 2020 : newsletter/2020_01_03.md - 1st January 2020 : newsletter/2020_01_01.md Where: 0_newsletter_index.md : Is the landing page of the newsletters. It's prepended with 0_ so it shows the first item when you do ls in the directory. It will be created from a template the first time you run it, then you can change the file to fit your liking. 2020.md : Is an automatic year summary done at the end of the year. 2020_01.md : Is an automatic month summary for the monthly rss done at the end of the month joining the changes of the month weeks. 2020_w01.md : Is an automatic week summary for the weekly rss done at the end of the week joining the changes of the week days. 2020_01_01.md : Is an automatic day summary for the daily rss. My first idea as a MkDocs user, and newborn plugin developer was to add the navigation items to the nav key in the config object, as it's more easy to add items to a dictionary I'm used to work with than to dive into the code and understand how MkDocs creates the navigation. As I understood from the docs, the files should be created in the on_files event. the problem with this approach is that the only event that allows you to change the config is the on_config event, which is before the on_files one, so you can't build the navigation this way after you've created the files. Next idea was to add the items in the on_nav event, that means creating yourself the Section , Pages , SectionPages or Link objects and append them to the nav.items . The problem is that MkDocs initializes and processes the Navigation object in the get_navigation function. If you want to add items with a plugin in the on_nav event, you need to manually run all the post processing functions such as building the pages attribute, by running the _get_by_type , _add_previous_and_next_links or _add_parent_links yourself. Additionally, when building the site you'll get the The following pages exist in the docs directory, but are not included in the \"nav\" configuration error, because that check is done before all plugins change the navigation in the on_nav object. The last approach is to build the files and tweak the navigation in the on_config event. This approach has the next advantages: You need less knowledge of how MkDocs works. You don't need to create the File or Files objects. You don't need to create the Page , Section , SectionPage objects. More robust as you rely on existent MkDocs functionality. We need to define: How to translate from a list of newsletter file names to the nav structure. Whether to build the nav from scratch on each build or reuse the done job.","title":"Proposals"},{"location":"adr/004-article_newsletter_structure/#how-to-translate-from-a-list-of-newsletter-file-names-to-the-nav-structure","text":"The complex part here is how to get the ordering of the elements in the nav right. We could: Create a nav_data dictionary with the following structure: { year : { 'index' : year.md , month_number : { 'index' : year_month.md , week_number : { 'index' : year_wweek_number.md , day : year_month_day.md } } } } And then translate the nav_data to the actual nav contents.","title":"How to translate from a list of newsletter file names to the nav structure"},{"location":"adr/004-article_newsletter_structure/#build-the-nav-from-scratch-or-reuse-previous-runs-nav","text":"We can either build the whole newsletter nav each time we build the site or we can store the nav somewhere and only append the new articles. The second option is more efficient in terms of energy, I don't want to store in the mkdocs.yml file as the newsletter nav can grow fast, making the file dirty. Another possibility is to save the nav in docs/newsletter/.newsletter_nav.yaml . If we store the newsletter nav dictionary, it would be difficult to deduce where does the new entries fit in so that the nav is still ordered. It would make more sense to store the nav_data object, but building that object is relatively cheap, so it may not be worth even storing it.","title":"Build the nav from scratch or reuse previous run's nav"},{"location":"adr/004-article_newsletter_structure/#decision","text":"Follow the only proposal regarding the structure, and we'll build the nav from scratch each time we build the site.","title":"Decision"},{"location":"adr/004-article_newsletter_structure/#consequences","text":"","title":"Consequences"},{"location":"adr/005-create_the_newsletter_articles/","text":"Status \u00b6 Accepted Based on: 004 Context \u00b6 We need to present the user the changes in the cleanest way: Have the minimum number of title levels, maybe a maximum of 3 levels. Group the related changes. Proposals \u00b6 To present the changes we want to: Group the articles by category and subcategory following the nav order. Group the changes by article ordered chronologically. A TOC doesn't make sense for the article stored in the mkdocs repository as it is already created by MkDocs. The skeleton of each article will be: Categories as title one, respecting the nav order, with a link to the category file if it exists. Subcategories as title two, respecting the nav order, with a link to the subcategory file if it exists. File title as title three, respecting the nav order, with a link to the subcategory file if it exists. Each change of the file will be added as bullet points ordered by date. Where the first line will be the first line of the commit and the body will be added below. If the scope of the change contains the information of the section of the file that it's changing, the link should point to that section instead. We need to differentiate the different types of changes: feat: New content additions perf: Improvements on existent articles fix: Corrections on existent articles refactor: Reorganization of articles We'll then create articles for each feed following the structure defined in 004 . Inspiration: mkdocs-tags mkdocs_blog mkdocs-rss-plugin Decision \u00b6 Implement the only proposal. Consequences \u00b6","title":"005: Article newsletter creation"},{"location":"adr/005-create_the_newsletter_articles/#status","text":"Accepted Based on: 004","title":"Status"},{"location":"adr/005-create_the_newsletter_articles/#context","text":"We need to present the user the changes in the cleanest way: Have the minimum number of title levels, maybe a maximum of 3 levels. Group the related changes.","title":"Context"},{"location":"adr/005-create_the_newsletter_articles/#proposals","text":"To present the changes we want to: Group the articles by category and subcategory following the nav order. Group the changes by article ordered chronologically. A TOC doesn't make sense for the article stored in the mkdocs repository as it is already created by MkDocs. The skeleton of each article will be: Categories as title one, respecting the nav order, with a link to the category file if it exists. Subcategories as title two, respecting the nav order, with a link to the subcategory file if it exists. File title as title three, respecting the nav order, with a link to the subcategory file if it exists. Each change of the file will be added as bullet points ordered by date. Where the first line will be the first line of the commit and the body will be added below. If the scope of the change contains the information of the section of the file that it's changing, the link should point to that section instead. We need to differentiate the different types of changes: feat: New content additions perf: Improvements on existent articles fix: Corrections on existent articles refactor: Reorganization of articles We'll then create articles for each feed following the structure defined in 004 . Inspiration: mkdocs-tags mkdocs_blog mkdocs-rss-plugin","title":"Proposals"},{"location":"adr/005-create_the_newsletter_articles/#decision","text":"Implement the only proposal.","title":"Decision"},{"location":"adr/005-create_the_newsletter_articles/#consequences","text":"","title":"Consequences"},{"location":"adr/006-rss_feed_creation/","text":"Status \u00b6 Accepted Context \u00b6 We want the readers to be notified by RSS of the changes of the documentation site. They should be able to choose the frequency of the updates. Proposals \u00b6 Once the newsletter mkdocs articles are created, we need to expose them through RSS feeds for each of the periodicities (daily, weekly, monthly and yearly). We have the newsletter articles both in markdown and in html if we use the on_post_build event. We need to create both the RSS site documentation and the entries content. The first one can be created with the contents of the mkdocs config object, the second ones using the html might be more interesting as it will have already the internal links resolved to working urls. We'll refactor the code from mkdocs-rss-plugin , as they've already solved the problem of creating an RSS for a MkDocs site. We need to decide: How to select the newsletters to be published in each feed. How to create each feed. Newsletter selection \u00b6 We're going to expose 15 entries in each feed. To get the 15 last newsletters for each feed we need to analyze the existent elements in the newsletter directory and then see the latest modification date of each of them. The published_date of the channel must be the published date of the last entry of the feed. How to create each feed \u00b6 We'll use the mkdocs-rss-plugin jinja2 template. I tried to use feedparser, but it's only for parsing and not for building RSSs. Decision \u00b6 Implement the only proposal. Consequences \u00b6","title":"006: RSS feed creation"},{"location":"adr/006-rss_feed_creation/#status","text":"Accepted","title":"Status"},{"location":"adr/006-rss_feed_creation/#context","text":"We want the readers to be notified by RSS of the changes of the documentation site. They should be able to choose the frequency of the updates.","title":"Context"},{"location":"adr/006-rss_feed_creation/#proposals","text":"Once the newsletter mkdocs articles are created, we need to expose them through RSS feeds for each of the periodicities (daily, weekly, monthly and yearly). We have the newsletter articles both in markdown and in html if we use the on_post_build event. We need to create both the RSS site documentation and the entries content. The first one can be created with the contents of the mkdocs config object, the second ones using the html might be more interesting as it will have already the internal links resolved to working urls. We'll refactor the code from mkdocs-rss-plugin , as they've already solved the problem of creating an RSS for a MkDocs site. We need to decide: How to select the newsletters to be published in each feed. How to create each feed.","title":"Proposals"},{"location":"adr/006-rss_feed_creation/#newsletter-selection","text":"We're going to expose 15 entries in each feed. To get the 15 last newsletters for each feed we need to analyze the existent elements in the newsletter directory and then see the latest modification date of each of them. The published_date of the channel must be the published date of the last entry of the feed.","title":"Newsletter selection"},{"location":"adr/006-rss_feed_creation/#how-to-create-each-feed","text":"We'll use the mkdocs-rss-plugin jinja2 template. I tried to use feedparser, but it's only for parsing and not for building RSSs.","title":"How to create each feed"},{"location":"adr/006-rss_feed_creation/#decision","text":"Implement the only proposal.","title":"Decision"},{"location":"adr/006-rss_feed_creation/#consequences","text":"","title":"Consequences"},{"location":"adr/00X-changelog_support/","text":"Status \u00b6 Draft Context \u00b6 Software documentation could benefit from the local newsletter, rss and email newsletter system. There are some changes that need to be done though. Instead of creating items per week, month or year, they should be created each time a release is made. Also, the template of the newsletter should be different. Proposals \u00b6 Change the template to ... Select which changes are added to the changelog How do we configure the plugin so it knows it's in changelog mode The CI reacts to the tag event to rebuild the documentation and create the newsletter. Decision \u00b6 Consequences \u00b6","title":"Status"},{"location":"adr/00X-changelog_support/#status","text":"Draft","title":"Status"},{"location":"adr/00X-changelog_support/#context","text":"Software documentation could benefit from the local newsletter, rss and email newsletter system. There are some changes that need to be done though. Instead of creating items per week, month or year, they should be created each time a release is made. Also, the template of the newsletter should be different.","title":"Context"},{"location":"adr/00X-changelog_support/#proposals","text":"Change the template to ... Select which changes are added to the changelog How do we configure the plugin so it knows it's in changelog mode The CI reacts to the tag event to rebuild the documentation and create the newsletter.","title":"Proposals"},{"location":"adr/00X-changelog_support/#decision","text":"","title":"Decision"},{"location":"adr/00X-changelog_support/#consequences","text":"","title":"Consequences"},{"location":"adr/00x-selection_of_changes_to_be_notified/","text":"Decide if the RSS needs to be updated and the newsletter being sent. \u00b6 We could have a configuration field where the user decides when the email/rss are generated. For example for the weekly event, the local newsletter will be created on Mondays, but if the sending event is meant to be on Thursdays, then the user can change the local newsletter manually before they are sent. Based on 1 and 2 , the default notifications day should be on Thursdays. This step will output a list of articles that need to be processed.","title":"00x selection of changes to be notified"},{"location":"adr/00x-selection_of_changes_to_be_notified/#decide-if-the-rss-needs-to-be-updated-and-the-newsletter-being-sent","text":"We could have a configuration field where the user decides when the email/rss are generated. For example for the weekly event, the local newsletter will be created on Mondays, but if the sending event is meant to be on Thursdays, then the user can change the local newsletter manually before they are sent. Based on 1 and 2 , the default notifications day should be on Thursdays. This step will output a list of articles that need to be processed.","title":"Decide if the RSS needs to be updated and the newsletter being sent."},{"location":"adr/00x-sending_the_email_newsletter/","text":"Sending the email newsletter \u00b6 We need to ask the user for the sender email configuration. Some may be in the plugin configuration in the mkdocs.yml while others (at least the password) should be taken from environmental variables. For each article selected an email is sent.","title":"00x sending the email newsletter"},{"location":"adr/00x-sending_the_email_newsletter/#sending-the-email-newsletter","text":"We need to ask the user for the sender email configuration. Some may be in the plugin configuration in the mkdocs.yml while others (at least the password) should be taken from environmental variables. For each article selected an email is sent.","title":"Sending the email newsletter"},{"location":"adr/00x-sending_the_notifications/","text":"Update the RSS and send the email. \u00b6 When we want to generate the RSS feed or the newsletter, we can do it in the on_post_build event, as mkdocs-rss-plugin does, maybe we can directly take the html of the newly generated newsletters and inject it in an email and in each RSS entry. This approach has another advantage, if the user changes the generated markdown newsletters, then the changes are automatically migrated to the RSS entries, not to the emails if they are already sent though.","title":"00x sending the notifications"},{"location":"adr/00x-sending_the_notifications/#update-the-rss-and-send-the-email","text":"When we want to generate the RSS feed or the newsletter, we can do it in the on_post_build event, as mkdocs-rss-plugin does, maybe we can directly take the html of the newly generated newsletters and inject it in an email and in each RSS entry. This approach has another advantage, if the user changes the generated markdown newsletters, then the changes are automatically migrated to the RSS entries, not to the emails if they are already sent though.","title":"Update the RSS and send the email."},{"location":"adr/adr/","text":"ADR are short text documents that captures an important architectural decision made along with its context and consequences. graph TD 001[001: High level analysis] 002[002: Initial MkDocs plugin design] 003[003: Selected changes to record] 004[004: Article newsletter structure] 005[005: Article newsletter creation] 006[006: RSS feed creation] 001 -- Extended --> 002 002 -- Extended --> 003 002 -- Extended --> 004 002 -- Extended --> 005 002 -- Extended --> 006 003 -- Extended --> 004 004 -- Extended --> 005 click 001 \"https://lyz-code.github.io/mkdocs-newsletter/adr/001-initial_approach\" _blank click 002 \"https://lyz-code.github.io/mkdocs-newsletter/adr/002-initial_plugin_design\" _blank click 003 \"https://lyz-code.github.io/mkdocs-newsletter/adr/003-select_the_changes_to_record\" _blank click 004 \"https://lyz-code.github.io/mkdocs-newsletter/adr/004-article_newsletter_structure\" _blank click 005 \"https://lyz-code.github.io/mkdocs-newsletter/adr/005-create_the_newsletter_articles\" _blank click 006 \"https://lyz-code.github.io/mkdocs-newsletter/adr/006-rss_feed_creation\" _blank 001:::accepted 002:::accepted 003:::accepted 004:::accepted 005:::accepted 006:::accepted classDef draft fill:#CDBFEA; classDef proposed fill:#B1CCE8; classDef accepted fill:#B1E8BA; classDef rejected fill:#E8B1B1; classDef deprecated fill:#E8B1B1; classDef superseeded fill:#E8E5B1;","title":"Architecture Decision Records"}]}