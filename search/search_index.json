{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"MkDocs Newsletter","text":"<p>MkDocs plugin to show the changes of documentation repositories in a user friendly format, at the same time that it's easy for the authors to maintain.</p> <p>It creates daily, weekly, monthly and yearly newsletter articles with the changes of each period. Those pages, stored under the <code>Newsletters</code> section, are filled with the changes extracted from the commit messages of the git history. The changes are grouped by categories, subcategories and then by file using the order of the site's navigation structure. RSS feeds are also created for each newsletter type, so it's easy for people to keep updated with the evolution of the site.</p> <p>It assumes that you're using semantic versioning or our enhanced version to create your commits. Only those changes that are interesting to the reader will be added to the newsletter. You can use mkdocs-rss-plugin instead if this workflow doesn't feel good.</p> <p></p> <p>Check a live version.</p>"},{"location":"#alternatives","title":"Alternatives","text":""},{"location":"#mkdocs-rss-plugin","title":"mkdocs-rss-plugin","text":"<p>This cool plugin creates two RSS feeds for the changes of the git history, one for new files and another for updated ones.</p> <p>Creating an RSS entry for each change, it's not the ideal solution for digital gardens because:</p> <ul> <li>The user will receive too many updates: In a normal day, you can edit up to     10 files, which will create 10 RSS entries. That can annoy the user so it     will stop reading your feed.</li> <li>The user will receive updates on irrelevant content: As an entry is created     for each change, styling and grammar corrections are sent as a new full     entry.</li> <li>The user receives no context of the change: The RSS entry links to the     article but not it's sections, so if you frequently edit a big file, the,     the user will see no point on the entry and skip it and in the end drop the     RSS.</li> </ul> <p>If you feel that your use case wont suffer from those conditions, I suggest you use their plugin instead, as it's much easier to use.</p>"},{"location":"#future-plans","title":"Future plans","text":"<p>If there is enough people interested, we may develop:</p> <ul> <li>Support more notification channels such as email     newsletters.</li> <li>Adding support for software repositories, to give updates on the releases.</li> </ul>"},{"location":"#references","title":"References","text":"<p>As most open sourced programs, <code>mkdocs-newsletter</code> is standing on the shoulders of giants, namely:</p> Pytest Testing framework, enhanced by the awesome pytest-cases library that made the parametrization of the tests a lovely experience. Mypy Python static type checker. Flakeheaven Python linter with lots of checks. Black Python formatter to keep a nice style without effort. Autoimport Python formatter to automatically fix wrong import statements. isort Python formatter to order the import statements. PDM Command line tool to manage the dependencies. Mkdocs To build this documentation site, with the Material theme. Safety To check the installed dependencies for known security vulnerabilities. Bandit To finds common security issues in Python code. Yamlfix YAML fixer."},{"location":"#contributing","title":"Contributing","text":"<p>For guidance on setting up a development environment, and how to make a contribution to mkdocs-newsletter, see Contributing to mkdocs-newsletter.</p>"},{"location":"#donations","title":"Donations","text":"<p> or </p> <p>If you are using some of my open-source tools, have enjoyed them, and want to say \"thanks\", this is a very strong way to do it.</p> <p>If your product/company depends on these tools, you can sponsor me to ensure I keep happily maintaining them.</p> <p>If these tools are helping you save money, time, effort, or frustrations; or they are helping you make money, be more productive, efficient, secure, enjoy a bit more your work, or get your product ready faster, this is a great way to show your appreciation. Thanks for that!</p> <p>And by sponsoring me, you are helping make these tools, that already help you, sustainable and healthy.</p>"},{"location":"contributing/","title":"Contributing","text":"<p>So you've started using <code>mkdocs-newsletter</code> and want to show your gratitude to the project, depending on your programming skills there are different ways to do so.</p>"},{"location":"contributing/#i-dont-know-how-to-program","title":"I don't know how to program","text":"<p>There are several ways you can contribute:</p> <ul> <li>Open an issue if you encounter     any bug or to let us know if you want a new feature to be implemented.</li> <li>Spread the word about the program.</li> <li>Review the documentation and try to improve     it.</li> </ul>"},{"location":"contributing/#i-know-how-to-program-in-python","title":"I know how to program in Python","text":"<p>If you have some python knowledge there are some additional ways to contribute. We've ordered the issues in milestones, check the issues in the smaller one, as it's where we'll be spending most of our efforts. Try the good first issues, as they are expected to be easier to get into the project.</p> <p>We develop the program with TDD, so we expect any contribution to have it's associated tests. We also try to maintain an updated documentation of the project, so think if your contribution needs to update it.</p> <p>We know that the expected code quality is above average. Therefore it might be changeling to get the initial grasp of the project structure, know how to make the tests, update the documentation or use all the project technology stack. but please don't let this fact discourage you from contributing:</p> <ul> <li>If you want to develop a new feature, explain how you'd like to do it in the related issue.</li> <li>If you don't know how to test your code, do the pull request without the tests     and we'll try to do them for you.</li> </ul>"},{"location":"contributing/#issues","title":"Issues","text":"<p>Questions, feature requests and bug reports are all welcome as issues. To report a security vulnerability, please see our security policy instead.</p> <p>To make it as simple as possible for us to help you, please include the output of the following call in your issue:</p> <pre><code>python -c \"import mkdocs_newsletter.version; print(mkdocs_newsletter.version.version_info())\"\n</code></pre> <p>or if you have <code>make</code> installed, you can use <code>make version</code>.</p> <p>Please try to always include the above unless you're unable to install <code>mkdocs-newsletter</code> or know it's not relevant to your question or feature request.</p>"},{"location":"contributing/#pull-requests","title":"Pull Requests","text":"<p>mkdocs-newsletter is released regularly so you should see your improvements release in a matter of days or weeks.</p> <p>Note</p> <p>Unless your change is trivial (typo, docs tweak etc.), please create an issue to discuss the change before creating a pull request.</p> <p>If you're looking for something to get your teeth into, check out the \"help wanted\" label on github.</p>"},{"location":"contributing/#development-facilities","title":"Development facilities","text":"<p>To make contributing as easy and fast as possible, you'll want to run tests and linting locally.</p> <p>tl;dr: use <code>make format</code> to fix formatting, <code>make</code> to run tests and linting &amp; <code>make docs</code> to build the docs.</p> <p>You'll need to have python 3.6, 3.7, or 3.8, virtualenv, git, and make installed.</p> <ul> <li> <p>Clone your fork and go into the repository directory:</p> <pre><code>git clone git@github.com:&lt;your username&gt;/mkdocs-newsletter.git\ncd mkdocs-newsletter\n</code></pre> </li> <li> <p>Set up the virtualenv for running tests:</p> <pre><code>virtualenv -p `which python3.7` env\nsource env/bin/activate\n</code></pre> </li> <li> <p>Install <code>pdm</code> our package manager with the next command or using any of the     other recommended     methods.</p> <pre><code>curl -sSL https://raw.githubusercontent.com/pdm-project/pdm/main/install-pdm.py | python3 -\n</code></pre> </li> <li> <p>Install mkdocs-newsletter, dependencies and configure the     pre-commits:</p> <pre><code>make install\n</code></pre> </li> <li> <p>Checkout a new branch and make your changes:</p> <pre><code>git checkout -b my-new-feature-branch\n</code></pre> </li> <li> <p>Fix formatting and imports: mkdocs-newsletter uses     black to enforce formatting and     isort to fix imports.</p> <pre><code>make format\n</code></pre> </li> <li> <p>Run tests and linting:</p> <pre><code>make\n</code></pre> <p>There are more sub-commands in Makefile like <code>test-code</code>, <code>test-examples</code>, <code>mypy</code> or <code>security</code> which you might want to use, but generally <code>make</code> should be all you need.</p> <p>If you need to pass specific arguments to pytest use the <code>ARGS</code> variable, for example <code>make test ARGs='-k test_markdownlint_passes'</code>.</p> </li> <li> <p>Build documentation: If you have changed the documentation, make sure it     builds the static site. Once built it will serve the documentation at     <code>localhost:8000</code>:</p> <pre><code>make docs\n</code></pre> </li> <li> <p>Commit, push, and create your pull request.</p> </li> <li> <p>Make a new release: To generate the changelog of the new changes, build the     package, upload to pypi and clean the build files use <code>make bump</code>.</p> </li> </ul> <p>We'd love you to contribute to mkdocs-newsletter!</p>"},{"location":"install/","title":"Installation","text":"<p>We've envisioned the plugin with zero configuration as it's quicker to develop and easier to use. If you'd like to change the default behaviour, please open an issue.</p> <pre><code>pip install mkdocs-newsletter\n</code></pre> <p>To enable this plugin, you need to declare it in your config file <code>mkdocs.yml</code>.</p> <pre><code>plugins:\n- git-revision-date-localized:\ntype: timeago\n- autolinks\n- section-index\n- mkdocs-newsletter\n</code></pre> <p>We rely on:</p> <ul> <li>git-revision-date-localized     to extract the latest modification date for each newsletter for the RSS.</li> <li>mkdocs-autolink-plugin     to create the links between the articles.</li> <li>mkdocs-section-index to     make the sections clickable.</li> </ul> <p>To create the RSS feeds well we also need the next configuration:</p> <pre><code>site_url: https://substitute.with.your.site.url\nmarkdown_extensions:\n- toc:\nbaselevel: 2\n</code></pre> <p>Finally make sure that you have a <code>nav</code> section in your <code>mkdocs.yml</code> file with at least one entry, otherwise the plugin won't work.</p>"},{"location":"install/#mkdocs-configuration-enhancements","title":"MkDocs configuration enhancements","text":"<p>There are some MkDocs tweaks that can make the plugin work better:</p> <ul> <li>Add newsletter information in the footer and the     header.</li> <li>Update the site automatically.</li> <li>Exclude the newsletters from the     search.</li> </ul>"},{"location":"install/#add-newsletter-information-in-the-footer-and-the-header","title":"Add newsletter information in the footer and the header","text":"<p>It can be useful to let know the readers that you publish the changes through newsletters and RSS feeds, we can do that in the footer and the header.</p> <p>This section is assuming you're using the Material theme. It may work on others but I haven't tested it</p>"},{"location":"install/#footer","title":"Footer","text":"<p>You can add the RSS icon to the Social links footer section that points to the newsletter landing page with the next snippet:</p> <pre><code>extra:\nsocial:\n- icon: fontawesome/solid/rss\nlink: https://your.site/newsletter/0_newsletter_index/\n</code></pre> <p>You can select from <code>fontawesome/solid/rss-square</code> or <code>fontawesome/solid/rss</code>.</p>"},{"location":"install/#header","title":"Header","text":"<p>You can add an announce banner at the top telling your readers to subscribe to the RSS feed by extending the theme and overriding the <code>announce</code> block with something like:</p> <p>Assuming that the override theme directory is <code>theme</code>:</p> <p>File: <code>mkdocs.yml</code></p> <pre><code>theme:\nname: material\ncustom_dir: theme\n</code></pre> <p>File: <code>theme/main.html</code></p> <pre><code>{% extends \"base.html\" %}\n\n{% block announce %}\n&lt;a href=\"https://your.site/newsletter/0_newsletter_index\"&gt;\n    For updates subscribe to the  &lt;strong&gt;RSS feed&lt;/strong&gt;\n    &lt;span class=\"rss icon\"&gt;\n    {% include \".icons/fontawesome/solid/rss.svg\" %}\n    &lt;/span&gt;\n&lt;/a&gt;\n{% endblock %}\n</code></pre>"},{"location":"install/#update-the-site-automatically","title":"Update the site automatically","text":"<p>It's useful to create a continuous integration pipeline to keep the site updated and automatically build the newsletters.</p> <p>If you're using github, you can use the next configuration:</p> File: <code>.github/workflows/update.yml</code> <pre><code>---\nname: github pages\n\non:\npush:\nbranches:\n- master\nschedule:\n- cron: 11 08 * * *\n\njobs:\ndeploy:\nruns-on: ubuntu-latest\nsteps:\n- uses: actions/checkout@v2\nwith:\npersist-credentials: false\n# Number of commits to fetch. 0 indicates all history.\n# Default: 1\nfetch-depth: 0\n\n- name: Setup Python\n# https://github.com/actions/virtual-environments/issues/1202\n# uses: actions/setup-python@v1\n# with:\n#   python-version: '3.7'\nuses: actions/setup-python@v2\nwith:\npython-version: 3.7.7\narchitecture: x64\n\n- name: Cache dependencies\nuses: actions/cache@v1\nwith:\npath: ~/.cache/pip\nkey: ${{ runner.os }}-pip-${{ hashFiles('**/requirements.txt') }}\nrestore-keys: |\n${{ runner.os }}-pip-\n\n- name: Install dependencies\nrun: pip install pip-tools\n\n- name: Update requirements\nrun: make update\n\n- name: Make the site\nrun: make build-docs\n\n- name: Commit files\nrun: |\ngit config --local user.email \"action@github.com\"\ngit config --local user.name \"GitHub Action\"\ngit add requirements.txt\ngit add docs/newsletter\ngit diff-index --quiet HEAD \\\n|| git commit -m \"chore: update dependency and publish newsletters\"\n\n- name: Push changes\nuses: ad-m/github-push-action@master\nwith:\ngithub_token: ${{ secrets.GITHUB_TOKEN }}\nbranch: master\n\n- name: Deploy\nuses: peaceiris/actions-gh-pages@v3\nwith:\ndeploy_key: ${{ secrets.ACTIONS_DEPLOY_KEY }}\npublish_dir: ./site\n</code></pre> <p>It assumes that you have the next <code>Makefile</code>:</p> File: <code>Makefile</code> <pre><code>.PHONY: update\nupdate:\n@echo \"-------------------------\"\n@echo \"- Updating dependencies -\"\n@echo \"-------------------------\"\n\nrm requirements.txt\n    touch requirements.txt\n    pip-compile -Ur requirements.in --allow-unsafe\n\n    pip install -r requirements.txt\n\n    @echo \"\"\n\n.PHONY: build-docs\nbuild-docs:\n@echo \"--------------------------\"\n@echo \"- Building documentation -\"\n@echo \"--------------------------\"\n\nmkdocs build\n\n    @echo \"\"\n</code></pre>"},{"location":"install/#exclude-the-newsletters-from-the-search","title":"Exclude the newsletters from the search","text":"<p>If you don't want to see the newsletters in the result of the search, use the mkdocs-exclude-search plugin to exclude all articles under <code>newsletter/</code>.</p> <p>To do so:</p> <ol> <li>Install the plugin with    <pre><code>pip install mkdocs-exclude-search\n</code></pre></li> <li>Add the following configuration to your <code>mkdocs.yml</code> <pre><code>plugins:\n- search\n- exclude-search:\nexclude:\n- newsletter/*\n</code></pre></li> </ol> <p>Note that <code>newsletter/*</code> excludes all markdown files within a directory and its children. The paths must be relative to the <code>docs/</code> directory.</p>"},{"location":"reference/","title":"Reference","text":""},{"location":"reference/#mkdocs_newsletter","title":"<code>mkdocs_newsletter</code>","text":"<p>Automatically create newsletters from the changes in a mkdocs repository.</p>"},{"location":"reference/#mkdocs_newsletter.Change","title":"<code>Change</code>","text":"<p>         Bases: <code>BaseModel</code></p> <p>Represent a single semantic change in a git repository.</p> <p>Attributes:</p> Name Type Description <code>date</code> <code>datetime</code> <p>When the change was done.</p> <code>summary</code> <code>str</code> <p>short description of the change.</p> <code>type_</code> <code>Optional[str]</code> <p>semantic type of change, such as feature or fix.</p> <code>message</code> <code>Optional[str]</code> <p>long description of the change.</p> <code>breaking</code> <code>bool</code> <p>if the change breaks previous functionality.</p> <code>category</code> <code>Optional[str]</code> <p>name of the group of files that share meaning.</p> <code>category_order</code> <code>Optional[int]</code> <p>order of the category against all categories.</p> <code>subcategory</code> <code>Optional[str]</code> <p>name of the subgroup of files that share meaning.</p> <code>category_order</code> <code>Optional[int]</code> <p>order of the subcategory against all subcategories.</p> <code>file_</code> <code>Optional[str]</code> <p>markdown file name.</p> <code>file_section</code> <code>Optional[str]</code> <p>title of the file containing the change.</p> <code>file_section_order</code> <code>Optional[int]</code> <p>order of the file in the subcategory or category that holds the file.</p> <code>file_subsection</code> <code>Optional[str]</code> <p>title of the section of the file the change belongs to.</p> Source code in <code>mkdocs_newsletter/model.py</code> <pre><code>class Change(BaseModel):\n\"\"\"Represent a single semantic change in a git repository.\n\n    Attributes:\n        date: When the change was done.\n        summary: short description of the change.\n        type_: semantic type of change, such as feature or fix.\n        message: long description of the change.\n        breaking: if the change breaks previous functionality.\n        category: name of the group of files that share meaning.\n        category_order: order of the category against all categories.\n        subcategory: name of the subgroup of files that share meaning.\n        category_order: order of the subcategory against all subcategories.\n        file_: markdown file name.\n        file_section: title of the file containing the change.\n        file_section_order: order of the file in the subcategory or category that holds\n            the file.\n        file_subsection: title of the section of the file the change belongs to.\n    \"\"\"\n\n    date: datetime\n    summary: str\n    scope: Optional[str]\n    type_: Optional[str]\n    message: Optional[str] = None\n    breaking: bool = False\n    publish: Optional[bool] = None\n    category: Optional[str] = None\n    category_order: Optional[int] = None\n    subcategory: Optional[str] = None\n    subcategory_order: Optional[int] = None\n    file_: Optional[str] = None\n    file_section: Optional[str] = None\n    file_section_order: Optional[int] = None\n    file_subsection: Optional[str] = None\n</code></pre>"},{"location":"reference/#mkdocs_newsletter.Newsletter","title":"<code>Newsletter</code>","text":"<p>         Bases: <code>BasePlugin</code></p> <p>Define the MkDocs plugin to create newsletters.</p> Source code in <code>mkdocs_newsletter/entrypoints/mkdocs_plugin.py</code> <pre><code>class Newsletter(BasePlugin):  # type: ignore\n\"\"\"Define the MkDocs plugin to create newsletters.\"\"\"\n\n    def __init__(self) -&gt; None:\n\"\"\"Initialize the basic attributes.\n\n        Attributes:\n            repo: Git repository to analyze.\n        \"\"\"\n        self.working_dir = os.getenv(\"NEWSLETTER_WORKING_DIR\", default=os.getcwd())\n        self.repo = Repo(self.working_dir)\n\n    def on_config(self, config: Config) -&gt; Config:\n\"\"\"Create the new newsletters and load them in the navigation.\n\n        Through the following steps:\n\n        * Detect which were the last changes for each of the feeds.\n        * Parse the changes from the git history that were done before the last\n            changes.\n        * Create the newsletter articles.\n        * Update the navigation.\n\n        Args:\n            config: MkDocs global configuration object.\n\n        Returns:\n            config: MkDocs config object with the new newsletters in the Newsletter\n                section.\n        \"\"\"\n        newsletter_dir = f\"{self.working_dir}/docs/newsletter\"\n        if not os.path.exists(newsletter_dir):\n            os.makedirs(newsletter_dir)\n        last_published_changes = last_newsletter_changes(newsletter_dir)\n        changes_to_publish = add_change_categories(\n            semantic_changes(self.repo, last_published_changes.min()), config\n        )\n        changes_per_feed = digital_garden_changes(\n            changes_to_publish,\n            last_published_changes,\n        )\n\n        create_newsletters(changes_per_feed, self.repo)\n        create_newsletter_landing_page(config, self.repo)\n\n        config = build_nav(config, newsletter_dir)\n\n        return config\n\n    # The * in the signature is to mimic the parent class signature\n    def on_post_build(self, *, config: Config) -&gt; None:\n\"\"\"Create the RSS feeds.\"\"\"\n        create_rss(config, self.working_dir)\n</code></pre>"},{"location":"reference/#mkdocs_newsletter.entrypoints.mkdocs_plugin.Newsletter.__init__","title":"<code>__init__()</code>","text":"<p>Initialize the basic attributes.</p> <p>Attributes:</p> Name Type Description <code>repo</code> <p>Git repository to analyze.</p> Source code in <code>mkdocs_newsletter/entrypoints/mkdocs_plugin.py</code> <pre><code>def __init__(self) -&gt; None:\n\"\"\"Initialize the basic attributes.\n\n    Attributes:\n        repo: Git repository to analyze.\n    \"\"\"\n    self.working_dir = os.getenv(\"NEWSLETTER_WORKING_DIR\", default=os.getcwd())\n    self.repo = Repo(self.working_dir)\n</code></pre>"},{"location":"reference/#mkdocs_newsletter.entrypoints.mkdocs_plugin.Newsletter.on_config","title":"<code>on_config(config)</code>","text":"<p>Create the new newsletters and load them in the navigation.</p> <p>Through the following steps:</p> <ul> <li>Detect which were the last changes for each of the feeds.</li> <li>Parse the changes from the git history that were done before the last     changes.</li> <li>Create the newsletter articles.</li> <li>Update the navigation.</li> </ul> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>Config</code> <p>MkDocs global configuration object.</p> required <p>Returns:</p> Name Type Description <code>config</code> <code>Config</code> <p>MkDocs config object with the new newsletters in the Newsletter section.</p> Source code in <code>mkdocs_newsletter/entrypoints/mkdocs_plugin.py</code> <pre><code>def on_config(self, config: Config) -&gt; Config:\n\"\"\"Create the new newsletters and load them in the navigation.\n\n    Through the following steps:\n\n    * Detect which were the last changes for each of the feeds.\n    * Parse the changes from the git history that were done before the last\n        changes.\n    * Create the newsletter articles.\n    * Update the navigation.\n\n    Args:\n        config: MkDocs global configuration object.\n\n    Returns:\n        config: MkDocs config object with the new newsletters in the Newsletter\n            section.\n    \"\"\"\n    newsletter_dir = f\"{self.working_dir}/docs/newsletter\"\n    if not os.path.exists(newsletter_dir):\n        os.makedirs(newsletter_dir)\n    last_published_changes = last_newsletter_changes(newsletter_dir)\n    changes_to_publish = add_change_categories(\n        semantic_changes(self.repo, last_published_changes.min()), config\n    )\n    changes_per_feed = digital_garden_changes(\n        changes_to_publish,\n        last_published_changes,\n    )\n\n    create_newsletters(changes_per_feed, self.repo)\n    create_newsletter_landing_page(config, self.repo)\n\n    config = build_nav(config, newsletter_dir)\n\n    return config\n</code></pre>"},{"location":"reference/#mkdocs_newsletter.entrypoints.mkdocs_plugin.Newsletter.on_post_build","title":"<code>on_post_build(*, config)</code>","text":"<p>Create the RSS feeds.</p> Source code in <code>mkdocs_newsletter/entrypoints/mkdocs_plugin.py</code> <pre><code>def on_post_build(self, *, config: Config) -&gt; None:\n\"\"\"Create the RSS feeds.\"\"\"\n    create_rss(config, self.working_dir)\n</code></pre>"},{"location":"reference/#mkdocs_newsletter.digital_garden_changes","title":"<code>digital_garden_changes(changes, last_published=None)</code>","text":"<p>Extract the changes that need to be published for digital_garden repositories.</p> <p>For a change to be published it needs to:</p> Be made before the first day of the year and after the last published change <p>in the year feed.</p> Be made before the first day of the month and after the last published change <p>in the month feed.</p> Be made before the last Monday and after the last published change in the <p>week feed.</p> <p>Parameters:</p> Name Type Description Default <code>changes</code> <code>List[Change]</code> <p>The list of Change objects to publish.</p> required <code>last_published</code> <code>Optional[LastNewsletter]</code> <p>last published date per feed type</p> <code>None</code> <p>Returns:</p> Name Type Description <code>changes</code> <code>DigitalGardenChanges</code> <p>Ordered changes to publish per feed.</p> Source code in <code>mkdocs_newsletter/services/newsletter.py</code> <pre><code>def digital_garden_changes(\n    changes: List[Change], last_published: Optional[LastNewsletter] = None\n) -&gt; DigitalGardenChanges:\n\"\"\"Extract the changes that need to be published for digital_garden repositories.\n\n    For a change to be published it needs to:\n\n    year: Be made before the first day of the year and after the last published change\n        in the year feed.\n    month: Be made before the first day of the month and after the last published change\n        in the month feed.\n    week: Be made before the last Monday and after the last published change in the\n        week feed.\n    day: Be made before today and after the last published change in the day feed.\n\n    Args:\n        changes: The list of Change objects to publish.\n        last_published: last published date per feed type\n\n    Returns:\n        changes: Ordered changes to publish per feed.\n    \"\"\"\n    now = datetime.datetime.now(tz.tzlocal())\n    today = now.replace(hour=0, minute=0, second=0, microsecond=0)\n    last_first_weekday = today - datetime.timedelta(days=now.weekday())\n    last_first_monthday = today.replace(day=1)\n    last_first_yearday = today.replace(day=1, month=1)\n\n    if last_published is None:\n        last_published = LastNewsletter()\n\n    return DigitalGardenChanges(\n        daily=[\n            change\n            for change in changes\n            if change.date &lt; today\n            and (last_published.daily is None or change.date &gt; last_published.daily)\n            and change.type_ in CHANGE_TYPE_TEXT\n        ],\n        weekly=[\n            change\n            for change in changes\n            if change.date &lt; last_first_weekday\n            and (last_published.weekly is None or change.date &gt; last_published.weekly)\n            and change.type_ in CHANGE_TYPE_TEXT\n        ],\n        monthly=[\n            change\n            for change in changes\n            if change.date &lt; last_first_monthday\n            and (last_published.monthly is None or change.date &gt; last_published.monthly)\n            and change.type_ in CHANGE_TYPE_TEXT\n        ],\n        yearly=[\n            change\n            for change in changes\n            if change.date &lt; last_first_yearday\n            and (last_published.yearly is None or change.date &gt; last_published.yearly)\n            and change.type_ in CHANGE_TYPE_TEXT\n        ],\n    )\n</code></pre>"},{"location":"reference/#mkdocs_newsletter.last_newsletter_changes","title":"<code>last_newsletter_changes(newsletter_dir)</code>","text":"<p>Extract the date of the last change of the last newsletter for each feed.</p> <p>Parameters:</p> Name Type Description Default <code>newsletter_dir</code> <code>str</code> <p>Directory containing the newsletter articles.</p> required <p>Returns:</p> Name Type Description <code>last_newsletter</code> <code>LastNewsletter</code> <p>LastNewsletter object.</p> Source code in <code>mkdocs_newsletter/services/newsletter.py</code> <pre><code>def last_newsletter_changes(newsletter_dir: str) -&gt; LastNewsletter:\n\"\"\"Extract the date of the last change of the last newsletter for each feed.\n\n    Args:\n        newsletter_dir: Directory containing the newsletter articles.\n\n    Returns:\n        last_newsletter: LastNewsletter object.\n    \"\"\"\n    newsletters = _list_newsletters(newsletter_dir)\n    last = LastNewsletter()\n\n    # Year feed: Saves the first day of the next year.\n    with suppress(IndexError):\n        last.yearly = newsletters.yearly[0].date + relativedelta(years=1)\n\n    # Month feed: Saves the first day of the next month.\n    with suppress(IndexError):\n        last_file_date = newsletters.monthly[0].date\n        last.monthly = datetime.datetime(\n            last_file_date.year + int(last_file_date.month / 12),\n            ((last_file_date.month % 12) + 1),\n            1,\n            tzinfo=tz.tzlocal(),\n        )\n\n    # Week feed: Saves the next Monday from the week of the week number.\n    with suppress(IndexError):\n        last.weekly = newsletters.weekly[0].date + datetime.timedelta(days=7)\n\n    # Daily feed: Saves the next day.\n    with suppress(IndexError):\n        last.daily = newsletters.daily[0].date + datetime.timedelta(days=1)\n\n    return last\n</code></pre>"},{"location":"reference/#mkdocs_newsletter.semantic_changes","title":"<code>semantic_changes(repo, min_date=None)</code>","text":"<p>Extract meaningful changes from a git repository.</p> <p>Parameters:</p> Name Type Description Default <code>repo</code> <code>Repo</code> <p>Git repository to analyze.</p> required <p>Returns:</p> Name Type Description <code>changes</code> <code>List[Change]</code> <p>List of Change objects.</p> Source code in <code>mkdocs_newsletter/services/git.py</code> <pre><code>def semantic_changes(\n    repo: Repo, min_date: Optional[datetime.datetime] = None\n) -&gt; List[Change]:\n\"\"\"Extract meaningful changes from a git repository.\n\n    Args:\n        repo: Git repository to analyze.\n\n    Returns:\n        changes: List of Change objects.\n    \"\"\"\n    now = datetime.datetime.now(tz=tz.tzlocal())\n    if min_date is None:\n        min_date = datetime.datetime(1800, 1, 1, tzinfo=tz.tzlocal())\n\n    commits = [\n        commit\n        for commit in repo.iter_commits(rev=repo.head.reference)\n        if commit.authored_datetime &lt; now and commit.authored_datetime &gt; min_date\n    ]\n\n    return commits_to_changes(commits)\n</code></pre>"},{"location":"usage/","title":"Usage","text":"<p>Every time you build the site, the plugin will inspect the git history and create the new newsletter articles under the <code>docs/newsletter</code> directory and configure the <code>Newsletter</code> section.</p> <p>The entrypoints for the authors are:</p> <ul> <li>Writing the commit messages.</li> <li>Manually changing the created newsletter     articles: to fix errors.</li> </ul>"},{"location":"usage/#commit-message-guidelines","title":"Commit message guidelines","text":"<p>The plugin assumes that you're using the Angular semantic versioning format to create the commits. Adapted to a documentation repository such as the digital gardens, the structure would be:</p> <pre><code>{type_of_change}({file_changed}): {short_description}\n\n{full_description}\n</code></pre> <p>Where:</p> <ul> <li> <p><code>type_of_change</code> is one of:</p> <ul> <li><code>feat</code>: Add new content to the repository, it can be a new file or new content on an existent file.</li> <li><code>fix</code>: Correct existing content.</li> <li><code>perf</code>: Improve existing content.</li> <li><code>refactor</code>: Reorder the articles content.</li> <li><code>style</code>: Correct grammar, orthography or broken links.</li> <li><code>ci</code>: Change the continuous integration pipelines.</li> <li><code>chore</code>: Update the dependencies required to build the site.</li> </ul> </li> <li> <p><code>file_changed</code>: Name of the changed file (without the <code>.md</code> extension).</p> </li> <li><code>short_description</code>: A succinct description of the change. It doesn't need to     start with a capitalize letter nor end with a dot.</li> <li><code>full_description</code>: A summary of the added changes.</li> </ul> <p>For example:</p> <pre><code>feat(adr): introduce the Architecture Decision Records\n\n[ADR](https://github.com/joelparkerhenderson/architecture_decision_record) are\nshort text documents that captures an important architectural decision made\nalong with its context and consequences.\n</code></pre> <p>Only changes of type <code>feat</code>, <code>fix</code>, <code>perf</code> or <code>refactor</code> will be added to the newsletter. The reader is not interested in the others.</p>"},{"location":"usage/#multiple-changes-in-the-same-commit","title":"Multiple changes in the same commit","text":"<p>When growing digital gardens, it's normal to do many small changes on different files. Making a commit for each of them is cumbersome and can break your writing flow. That's why the plugin is able to parse different changes from the same commit. For example:</p> <pre><code>feat(pexpect): introduce the pexpect python library\n\nA pure Python module for spawning\nchild applications; controlling them; and responding to expected patterns in\ntheir output. Pexpect works like Don Libes\u2019 Expect. Pexpect allows your script\nto spawn a child application and control it as if a human were typing commands.\n\nstyle(prompt_toolkit): correct links and indentations\n\nfix(python_snippets): explain how to show the message in custom exceptions\n\nfeat(python_snippets): explain how to import a module or object from within a python program\n</code></pre>"},{"location":"usage/#link-specific-parts-of-the-articles","title":"Link specific parts of the articles","text":"<p>You can specify the section of the article where the change has been made by appending the anchor to the file changed. For example:</p> <pre><code>perf(prometheus_installation#upgrading-notes): Add upgrading notes from 10.x -&gt; 11.1.7\n</code></pre> <p>The format of the anchor can be Markdown's default or you can use the user friendly one with caps and spaces <code>perf(prometheus_installation#Upgrading notes)</code>.</p>"},{"location":"usage/#rich-full-description-content","title":"Rich full description content","text":"<p>The <code>full_description</code> content will be processed by MkDocs, that means that all it's features applies, such as autolinking or admonitions.</p> <pre><code>perf(prometheus_installation): Add upgrading notes from 10.x -&gt; 11.1.7\n\n!!! warning \"Don't upgrade to 12.x if you're still using Helm 2.\"\n\n    Helm is deprecated and you should migrate to v3.\n</code></pre>"},{"location":"usage/#manual-newsletter-changes","title":"Manual newsletter changes","text":"<p>To change the contents of the newsletters directly edit the files under <code>docs/newsletters</code>.</p>"},{"location":"adr/001-initial_approach/","title":"001: High level problem analysis","text":""},{"location":"adr/001-initial_approach/#status","title":"Status","text":"<p>Accepted</p> <p>Extended by: 002</p>"},{"location":"adr/001-initial_approach/#context","title":"Context","text":"<p>Gathering knowledge in my blue book has been a pleasant experience in the last year. The only drawback of the system is that I don't know a user friendly way to inform the readers of content updates or fixes, such as an RSS feed of/and a periodic newsletter.</p> <p>That means that when the user stumbles upon the site, they spend a limited amount of time reading it, and then forgets of it's existence.</p> <p>If they see themselves back to the site, they don't know what have they've already seen, which can make them feel lost or loosing their time.</p> <p>Even if they clone the repository, they need to go through the log to see the changes, which is awful.</p> <p>And that means that all the efforts we put into growing our digital gardens or our software applications is not appreciated all that it should be.</p> <p>If we created a way to show them what has changed in a friendly way we will:</p> <ul> <li>Make their experience more pleasant.</li> <li>Make them more prone to visit the site again.</li> </ul> <p>We must be careful though, we don't want to worsen the bombardment of information we are suffering. We need to notify the user in a respectful way by sending them only relevant content at the pace they choose to.</p> <p>For the idea to work, we'd first need that the authors want to use the solution. So we need to build a system that doesn't increase the mental load or effort to a point that makes it unappealing. That can be done by:</p> <ul> <li>Automating all the processes that we can.</li> <li>Reducing to the minimum the author entrypoints.</li> <li>Making it easy for them to introduce the manual data that we need.</li> <li>Reduce the deviation from their current workflow.</li> </ul>"},{"location":"adr/001-initial_approach/#proposals","title":"Proposals","text":"<p>To solve the issue we need to decide:</p> <ul> <li>Which updates are relevant.</li> <li>How to reduce the number of notifications the user receives.</li> <li>Which notification channels we want to support.</li> <li>Which programming solution to use.</li> </ul>"},{"location":"adr/001-initial_approach/#how-to-extract-relevant-changes","title":"How to extract relevant changes","text":""},{"location":"adr/001-initial_approach/#manual-processing","title":"Manual processing","text":"<p>At the time of building the update, we could manually review all the changes done since the last update and store that information in a programmatically processable way.</p> <p>The downside is that we'll need to spend a relative big amount of time to review content written in the past. I found myself skipping these batch processing tasks in the past, as my brain sees them as dreadful, long and heavy.</p>"},{"location":"adr/001-initial_approach/#use-semantic-versioning-in-git-commit-messages","title":"Use semantic versioning in git commit messages","text":"<p>To give semantic meaning to the changes introduced in the repository, we can use the semantic versioning principles to classify and describe each change in a way that can be programmatically decide if it's worth publishing.</p> <p>The idea is to create commits following a specific format that describes what kind of change you're making. I've been following this practice for a while with the following personal commit convention:</p> <pre><code>{type_of_change}({file_changed}): {short_description}\n{full_description}\n</code></pre> <p>Where:</p> <ul> <li> <p><code>type_of_change</code> is one of:</p> </li> <li> <p><code>feat</code>: Add new content to the repository, it can be a new file or new content on an     existent file.</p> </li> <li><code>fix</code>: Correct existing content.</li> <li><code>style</code>: Correct grammar, orthography or broken links.</li> <li><code>ci</code>: Change the continuous integration pipelines.</li> <li> <p><code>chore</code>: Update the python dependencies required to build the site.</p> </li> <li> <p><code>file_changed</code>: name of the file changed (without the <code>.md</code> extension).</p> </li> <li><code>short_description</code>: A succinct description of the change. It doesn't need to     start with a capitalize letter nor end with a dot.</li> <li><code>full_description</code>: A summary of the added changes.</li> </ul> <p>For example: a single feat commit or a multientry commit</p> <p>With this method the responsibility of giving meaning to the changes is shared in time, which makes the task more appealing and less heavy. Additionally, with the IDE support, creating the commit messages is easier as you can copy and paste or autocomplete from the changes themselves.</p>"},{"location":"adr/001-initial_approach/#how-to-reduce-the-number-of-notifications","title":"How to reduce the number of notifications","text":"<p>There are cases where the user is still spammed even if we select the relevant changes.</p> <p>We can copy the solution adopted by the system's monitorization solutions, which is to group the changes to reduce the notifications.</p> <p>We should present different levels of aggregation, so they can receive daily, weekly or monthly notifications.</p>"},{"location":"adr/001-initial_approach/#which-notification-channels-we-want-to-support","title":"Which notification channels we want to support","text":"<p>Different users use different tools to get updates on what's going in the world. We can expose the updates through:</p> <ul> <li>An article in the documentation site.</li> <li>RSS.</li> <li>Email newsletter.</li> <li>API.</li> <li>Reddit.</li> <li>Hackernews.</li> <li>GNUsocial.</li> <li>Twitter.</li> <li>XMPP/Jabber</li> <li>Telegram</li> </ul> <p>The article in the documentation makes sense because it can be the landing page for the rest of channels, which can trigger further page views.</p> <p>Most of the people around me, whom I want to share my updates use RSS, which is an awesome protocol that is sadly being replaced by Twitter like webs, and we don't want that to happen. I feel that only \"technical\" users use this technology though.</p> <p>Everyone has an email, and sending mails through Python is easy, so it can be the easiest path to reach the global public.</p> <p>For the more technical ones, extracting the data from an API can help gluing together other functionalities. It could help if people want to extend the functionality that we give, for example by creating more specific RSS feeds based on categories. As we have a static site, it will only support GET methods, and we will already publish all the information in RSS format, which is parseable by programs, so adding another enpoint that exposes the same data in json format doesn't make much sense.</p> <p>I haven't used Reddit or Hackernews enough to know if it makes sense either this channel.</p> <p>I think GNUsocial and Twitter are wrongly being used to replace RSS, so it won't be a priority.</p> <p>A similar argument applies instant message solutions like XMPP or Telegram.</p>"},{"location":"adr/001-initial_approach/#which-programming-solution-to-use","title":"Which programming solution to use","text":"<p>To create the functionality, we'll need to:</p> <ul> <li>Semantic versioning information given by the user in the commit messages since     the last change.</li> <li>Link the files mentioned in the commit messages to actual working links.</li> </ul> <p>The processing can be done through:</p> <ul> <li> <p>A mkdocs plugin so it creates it at   build time. It can be inspired by:</p> <ul> <li>mkdocs-new-features-notifier</li> <li>mkdocs_blog</li> <li>mkdocs_latest_release_plugin</li> </ul> </li> <li> <p>An existent external command line tool such as     python-semantic-release     and commitizen bump.</p> </li> <li> <p>A complete new external command line tool.</p> </li> <li> <p>An hybrid between both solutions, like mike.</p> </li> </ul>"},{"location":"adr/001-initial_approach/#developing-a-mkdocs-plugin","title":"Developing a mkdocs plugin","text":"<p>The advantages are:</p> <ul> <li>It will be easier for people to use, as it already exists a widely used plugin     system in MkDocs.</li> <li>It will be easier for us too, as the plugin system gives a lot of information     on the articles, so making working links should be easy.</li> </ul> <p>The disadvantages are that we'll need to:</p> <ul> <li>Assume that the user is not meant to manually trigger the updates creation.     They will need to use a periodic automatic process similar to the one that     generates the website.</li> </ul>"},{"location":"adr/001-initial_approach/#decision","title":"Decision","text":"<p>We will develop a Mkdocs plugin that creates MkDocs articles whose content:</p> <ul> <li>Contains only relevant updates, deduced by the commit     messages of the     repository.</li> <li>Updates are grouped to reduce the user     notifications.</li> <li>Is exposed to the user with different levels of aggregation, such as: real     time, daily, weekly, monthly or yearly.</li> <li>Is exposed to the user through:<ul> <li>Articles in the same MkDocs site.</li> <li>RSS feeds.</li> <li>Email newsletters.</li> </ul> </li> </ul>"},{"location":"adr/001-initial_approach/#consequences","title":"Consequences","text":"<p>The user will be able to be kept updated of the relevant MkDocs site changes at the pace they desire.</p> <p>That will:</p> <ul> <li>Make their browsing experience more pleasant.</li> <li>Make them more prone to visit the site again.</li> </ul> <p>For the authors it will mean that they need to:</p> <ul> <li>Spend more time and thought writing the commit messages.</li> <li>Be tied to the solution we can give them, or contribute the desired changes.</li> <li>Debug possible errors produced by the increase of complexity of the system.</li> </ul> <p>For us it will mean that we'll need to:</p> <ul> <li>Build and maintain the logic and code for:<ul> <li>Extracting and grouping the relevant updates.</li> <li>Sending the notifications.</li> </ul> </li> <li>Keep the system updated.</li> <li>React to security vulnerabilities.</li> <li>React to issues and pull requests.</li> </ul>"},{"location":"adr/002-initial_plugin_design/","title":"002: Initial mkdocs plugin design","text":""},{"location":"adr/002-initial_plugin_design/#status","title":"Status","text":"<p>Accepted</p> <p>Based on: 001</p> <p>Extended by: 003, 004, and 005.</p>"},{"location":"adr/002-initial_plugin_design/#context","title":"Context","text":"<p>Taking 001 as a starting point, we want to define the processes that the mkdocs plugin need to have to fulfill the desired requirements.</p>"},{"location":"adr/002-initial_plugin_design/#proposals","title":"Proposals","text":"<p>The plugin will consist on the following phases:</p> <ul> <li>Select the changes that need to be recorded.</li> <li>Create the newsletter articles from those changes.</li> <li>Build the MkDocs nav with the newsletter articles</li> <li>Decide which changes need to be notified</li> <li>Send the notifications:<ul> <li>Update the RSS</li> <li>Send the email.</li> </ul> </li> </ul>"},{"location":"adr/002-initial_plugin_design/#decision","title":"Decision","text":"<p>Implement the only proposal.</p>"},{"location":"adr/002-initial_plugin_design/#consequences","title":"Consequences","text":""},{"location":"adr/003-select_the_changes_to_record/","title":"003: Select the changes to record","text":""},{"location":"adr/003-select_the_changes_to_record/#status","title":"Status","text":"<p>Accepted.</p> <p>Based on: 002, 004</p>"},{"location":"adr/003-select_the_changes_to_record/#context","title":"Context","text":"<p>We need to create some logic that reads from the git log to:</p> <ul> <li> <p>Extract the last published changes.  To     update the articles and feeds, we need to know which changes have been     already published, so subsequent mkdocs build processes don't repeat work     already done.</p> </li> <li> <p>Parse the commit messages to extract the     semantic versioning information from them.</p> <p>The message must follow the angular commit guidelines with the exception that we'll allow many changes in the same commit message.</p> </li> <li> <p>Extract file context from the MkDocs nav</p> </li> <li>Get the changes that need to be added to the newsletter     articles.     We've defined different levels of aggregation for the user to choose how     often they want to be notified: daily, weekly, monthly or yearly.</li> </ul>"},{"location":"adr/003-select_the_changes_to_record/#proposals","title":"Proposals","text":""},{"location":"adr/003-select_the_changes_to_record/#extract-the-last-published-changes","title":"Extract the last published changes","text":"<p>We can:</p> <ul> <li>Add meaningful tags to the repository: If we create a tag <code>last_weekly</code> on the     commit of the last published changed for the weekly feed, then we can     add to the changes to publish only those posterior to that commit.</li> <li>Save the last commit ids in a file in the repo: If we create a hidden     <code>.last_published.json</code> with the last commit id of each feed type,     we can add to the feeds only the changes that are posterior to those     commits.</li> <li>Save the last commit ids in the mkdocs.yaml file: We can save the last     commit ids in the configuration section of the plugin in the mkdocs.yaml     file.</li> <li>Deduce the last published date from existent articles: We already have this     information in the existent articles. All we would need to do is analyze the     files in the <code>on_files</code> and deduce the last content publication.</li> </ul>"},{"location":"adr/003-select_the_changes_to_record/#add-meaningful-tags-to-the-repository","title":"Add meaningful tags to the repository","text":"<p>Using tags has the advantage that we could reuse the <code>Repo</code> object to extract the information, which we already use in the services that process the changes. The disadvantage is that we'll pollute the git repository with tags that may not be interesting to the user. In the digital garden case, it's not a problem, but it can be in the changelog one.</p>"},{"location":"adr/003-select_the_changes_to_record/#save-the-last-commit-ids-in-a-file-in-the-repo","title":"Save the last commit ids in a file in the repo","text":"<p>Storing the commit ids in a hidden json file has the advantage that we don't pollute the git repository, we can use the <code>json</code> export and import functionality of pydantic. The disadvantage is that we'll create an additional file in the repository. cruft uses this method.</p>"},{"location":"adr/003-select_the_changes_to_record/#save-the-last-commit-ids-in-the-mkdocsyaml-file","title":"Save the last commit ids in the mkdocs.yaml file","text":"<p>Storing the commit ids in the mkdocs.yaml file has the advantage that it doesn't pollute either the git repository nor the project directory. The disadvantage is that it pollutes the mkdocs configuration file.</p>"},{"location":"adr/003-select_the_changes_to_record/#deduce-the-last-published-date-from-existent-articles","title":"Deduce the last published date from existent articles","text":"<p>Using the existent articles has these advantages:</p> <ul> <li>It doesn't pollute either the git repository, nor the project directory nor     the mkdocs configuration file.</li> <li>We can fetch the last published date per feed before parsing the commits, so     instead of analyzing the whole history, we can go from the newest till the     desired dates, making the algorithm more efficient..</li> <li>We don't overwrite the existent articles, so if the user makes changes on     them, they are respected.</li> </ul> <p>The disadvantage is that we need to code the extraction of that dates from the files collection, but it should not be difficult.</p> <p>Assuming that we have the existent articles organized following 004, we can create a function that reads the <code>files</code> attribute from the <code>on_files</code> event and deduces the date of the last change of the last newsletter article for each feed.</p>"},{"location":"adr/003-select_the_changes_to_record/#parse-the-commit-messages","title":"Parse the commit messages","text":"<p>We can:</p> <ul> <li>Use the     python-semantic-release     library.</li> <li>Use the commitizen library.</li> <li>Write our own parser.</li> </ul> <p>After reviewing the existent libraries, I've found that python-semantic-release exposes the parsed data in a friendlier way. The only drawback is that it uses NamedTuples for the objects that hold the parsed data, so if we want to change one, we need to create a new one from the old.</p> <p>Using an existent library, if it's well maintained, is always better than writing your own.</p>"},{"location":"adr/003-select_the_changes_to_record/#extract-file-context-from-the-mkdocs-nav","title":"Extract file context from the MkDocs nav","text":"<p>For each file that contains changes, we need to deduce the relative position in the nav against the rest of articles. This is necessary so we're able to group changes together by category, subcategory and file later in the newsletter creation.</p> <p>We can use the Deepdiff to locate the file in the nav tree, and then extract the context information from the path.</p>"},{"location":"adr/003-select_the_changes_to_record/#get-the-changes-that-need-to-be-added-to-the-newsletter-articles","title":"Get the changes that need to be added to the newsletter articles","text":"<p>For a change to be added to each feed it needs to:</p> <ul> <li>year: Be made before the first day of the year and after the last published     change in the year feed.</li> <li>month: Be made before the first day of the month and after the last published     change in the month feed.</li> <li>week: Be made before the last Monday and after the last published change in     the week feed.</li> <li>day: Be made before today and after the last published change in the day     feed.</li> </ul>"},{"location":"adr/003-select_the_changes_to_record/#decision","title":"Decision","text":"<p>We will:</p> <ul> <li>Run this phase in the     <code>on_files</code> MkDocs     event to be able to have the list of articles to process.</li> <li>Deduce the last published date from existent     articles as it's     the cleanest solution in terms of repository pollution.</li> <li>Extract the last published dates before we parse the commit messages.</li> <li>Process only the commits that are posterior to those dates.</li> <li>Use python-semantic-release library to parse the commit messages.</li> <li>Extract file context from the MkDocs nav</li> <li>Get the changes that need to be added to the newsletter articles with the     different feeds.</li> </ul>"},{"location":"adr/003-select_the_changes_to_record/#consequences","title":"Consequences","text":"<p>We don't have to write the parsing logic, it's maintained by the community and it needs few changes to fulfill our needs.</p> <p>Advantages:</p> <ul> <li>We'll know between builds which changes have been already published.</li> <li>We'll reduce the amount of commits that we parse, thus making the process more     efficient.</li> <li>We wont overwrite manual user changes in the published articles.</li> </ul> <p>Disadvantages:</p> <ul> <li>We need to code and maintain the extraction of last published date from the     list of repository files.</li> </ul>"},{"location":"adr/004-article_newsletter_structure/","title":"004: Article newsletter structure","text":""},{"location":"adr/004-article_newsletter_structure/#status","title":"Status","text":"<p>Accepted</p>"},{"location":"adr/004-article_newsletter_structure/#context","title":"Context","text":"<p>We want to define how to organize the articles that contain the updates as a section of the MkDocs site in a way that:</p> <ul> <li>It's easy and pleasant for the user to navigate.</li> <li>It's easy for us to parse programmatically.</li> </ul>"},{"location":"adr/004-article_newsletter_structure/#proposals","title":"Proposals","text":"<p>The frequency of updates can be weekly or monthly, structured in a mkdocs nav similar to:</p> <pre><code>Newsletters:\n- newsletter/0_newsletter_index.md\n- 2020:\n- newsletter/2020.md\n- February of 2020:\n- newsletter/2020_01.md\n- 6th Week of 2020:\n- newsletter/2020_w06.md\n- 11st February 2020: newsletter/2020_01_01.md\n- 5th Week of 2020:\n- newsletter/2020_w05.md\n- 1st February 2020: newsletter/2020_01_01.md\n- January of 2020:\n- newsletter/2020_01.md\n- 1st Week of 2020:\n- newsletter/2020_w01.md\n- 3rd January 2020: newsletter/2020_01_03.md\n- 1st January 2020: newsletter/2020_01_01.md\n</code></pre> <p>Where:</p> <ul> <li><code>0_newsletter_index.md</code>: Is the landing page of the newsletters. It's     prepended with <code>0_</code> so it shows the first item when you do <code>ls</code> in the     directory. It will be created from a template the first time you run it,     then you can change the file to fit your liking.</li> <li><code>2020.md</code>: Is an automatic year summary done at the end of the year.</li> <li><code>2020_01.md</code>: Is an automatic month summary for the monthly rss done at the end     of the month joining the changes of the month weeks.</li> <li><code>2020_w01.md</code>: Is an automatic week summary for the weekly rss done at the     end of the week joining the changes of the week days.</li> <li><code>2020_01_01.md</code>: Is an automatic day summary for the daily rss.</li> </ul> <p>My first idea as a MkDocs user, and newborn plugin developer was to add the navigation items to the <code>nav</code> key in the <code>config</code> object, as it's more easy to add items to a dictionary I'm used to work with than to dive into the code and understand how MkDocs creates the navigation. As I understood from the docs, the files should be created in the <code>on_files</code> event. the problem with this approach is that the only event that allows you to change the <code>config</code> is the <code>on_config</code> event, which is before the <code>on_files</code> one, so you can't build the navigation this way after you've created the files.</p> <p>Next idea was to add the items in the <code>on_nav</code> event, that means creating yourself the <code>Section</code>, <code>Pages</code>, <code>SectionPages</code> or <code>Link</code> objects and append them to the <code>nav.items</code>.  The problem is that MkDocs initializes and processes the <code>Navigation</code> object in the <code>get_navigation</code> function. If you want to add items with a plugin in the <code>on_nav</code> event, you need to manually run all the post processing functions such as building the <code>pages</code> attribute, by running the <code>_get_by_type</code>, <code>_add_previous_and_next_links</code> or <code>_add_parent_links</code> yourself. Additionally, when building the site you'll get the <code>The following pages exist in the docs directory, but are not included in the \"nav\" configuration</code> error, because that check is done before all plugins change the navigation in the <code>on_nav</code> object.</p> <p>The last approach is to build the files and tweak the navigation in the <code>on_config</code> event. This approach has the next advantages:</p> <ul> <li>You need less knowledge of how MkDocs works.</li> <li>You don't need to create the <code>File</code> or <code>Files</code> objects.</li> <li>You don't need to create the <code>Page</code>, <code>Section</code>, <code>SectionPage</code> objects.</li> <li>More robust as you rely on existent MkDocs functionality.</li> </ul> <p>We need to define:</p> <ul> <li>How to translate from a list of newsletter file names to the nav structure.</li> <li>Whether to build the nav from scratch on each build or reuse the done job.</li> </ul>"},{"location":"adr/004-article_newsletter_structure/#how-to-translate-from-a-list-of-newsletter-file-names-to-the-nav-structure","title":"How to translate from a list of newsletter file names to the nav structure","text":"<p>The complex part here is how to get the ordering of the elements in the nav right. We could:</p> <p>Create a <code>nav_data</code> dictionary with the following structure:     <pre><code>{\n    year: {\n'index': year.md,\n        month_number: {\n'index': year_month.md,\n            week_number: {\n'index': year_wweek_number.md,\n                day: year_month_day.md\n}\n}\n}\n}\n</code></pre></p> <p>And then translate the <code>nav_data</code> to the actual <code>nav</code> contents.</p>"},{"location":"adr/004-article_newsletter_structure/#build-the-nav-from-scratch-or-reuse-previous-runs-nav","title":"Build the nav from scratch or reuse previous run's nav","text":"<p>We can either build the whole newsletter nav each time we build the site or we can store the nav somewhere and only append the new articles. The second option is more efficient in terms of energy, I don't want to store in the <code>mkdocs.yml</code> file as the newsletter nav can grow fast, making the file dirty. Another possibility is to save the nav in <code>docs/newsletter/.newsletter_nav.yaml</code>.</p> <p>If we store the newsletter nav dictionary, it would be difficult to deduce where does the new entries fit in so that the nav is still ordered. It would make more sense to store the <code>nav_data</code> object, but building that object is relatively cheap, so it may not be worth even storing it.</p>"},{"location":"adr/004-article_newsletter_structure/#decision","title":"Decision","text":"<p>Follow the only proposal regarding the structure, and we'll build the nav from scratch each time we build the site.</p>"},{"location":"adr/004-article_newsletter_structure/#consequences","title":"Consequences","text":""},{"location":"adr/005-create_the_newsletter_articles/","title":"005: Article newsletter creation","text":""},{"location":"adr/005-create_the_newsletter_articles/#status","title":"Status","text":"<p>Accepted</p> <p>Based on: 004</p>"},{"location":"adr/005-create_the_newsletter_articles/#context","title":"Context","text":"<p>We need to present the user the changes in the cleanest way:</p> <ul> <li>Have the minimum number of title levels, maybe a maximum of 3 levels.</li> <li>Group the related changes.</li> </ul>"},{"location":"adr/005-create_the_newsletter_articles/#proposals","title":"Proposals","text":"<p>To present the changes we want to:</p> <ul> <li>Group the articles by category and subcategory following the nav order.</li> <li>Group the changes by article ordered chronologically.</li> </ul> <p>A TOC doesn't make sense for the article stored in the mkdocs repository as it is already created by MkDocs.</p> <p>The skeleton of each article will be:</p> <ul> <li>Categories as title one, respecting the nav order, with a link to the category     file if it exists.</li> <li>Subcategories as title two, respecting the nav order, with a link to the     subcategory file if it exists.</li> <li>File title as title three, respecting the nav order, with a link to the     subcategory file if it exists.</li> <li> <p>Each change of the file will be added as bullet points ordered by date.     Where the first line will be the first line of the commit and the body will     be added below.</p> <p>If the scope of the change contains the information of the section of the file that it's changing, the link should point to that section instead.</p> <p>We need to differentiate the different types of changes:</p> <ul> <li>feat: New content additions</li> <li>perf: Improvements on existent articles</li> <li>fix: Corrections on existent articles</li> <li>refactor: Reorganization of articles</li> </ul> </li> </ul> <p>We'll then create articles for each feed following the structure defined in 004.</p> <p>Inspiration:</p> <ul> <li>mkdocs-tags</li> <li>mkdocs_blog</li> <li>mkdocs-rss-plugin</li> </ul>"},{"location":"adr/005-create_the_newsletter_articles/#decision","title":"Decision","text":"<p>Implement the only proposal.</p>"},{"location":"adr/005-create_the_newsletter_articles/#consequences","title":"Consequences","text":""},{"location":"adr/006-rss_feed_creation/","title":"006: RSS feed creation","text":""},{"location":"adr/006-rss_feed_creation/#status","title":"Status","text":"<p>Accepted</p>"},{"location":"adr/006-rss_feed_creation/#context","title":"Context","text":"<p>We want the readers to be notified by RSS of the changes of the documentation site. They should be able to choose the frequency of the updates.</p>"},{"location":"adr/006-rss_feed_creation/#proposals","title":"Proposals","text":"<p>Once the newsletter mkdocs articles are created, we need to expose them through RSS feeds for each of the periodicities (daily, weekly, monthly and yearly).</p> <p>We have the newsletter articles both in markdown and in html if we use the <code>on_post_build</code> event.</p> <p>We need to create both the RSS site documentation and the entries content. The first one can be created with the contents of the mkdocs <code>config</code> object, the second ones using the html might be more interesting as it will have already the internal links resolved to working urls.</p> <p>We'll refactor the code from mkdocs-rss-plugin, as they've already solved the problem of creating an RSS for a MkDocs site.</p> <p>We need to decide:</p> <ul> <li>How to select the newsletters to be published in each     feed.</li> <li>How to create each feed.</li> </ul>"},{"location":"adr/006-rss_feed_creation/#newsletter-selection","title":"Newsletter selection","text":"<p>We're going to expose 15 entries in each feed.</p> <p>To get the 15 last newsletters for each feed we need to analyze the existent elements in the newsletter directory and then see the latest modification date of each of them.</p> <p>The <code>published_date</code> of the channel must be the published date of the last entry of the feed.</p>"},{"location":"adr/006-rss_feed_creation/#how-to-create-each-feed","title":"How to create each feed","text":"<p>We'll use the mkdocs-rss-plugin jinja2 template. I tried to use feedparser, but it's only for parsing and not for building RSSs.</p>"},{"location":"adr/006-rss_feed_creation/#decision","title":"Decision","text":"<p>Implement the only proposal.</p>"},{"location":"adr/006-rss_feed_creation/#consequences","title":"Consequences","text":""},{"location":"adr/00X-changelog_support/","title":"00X: Changelog support","text":""},{"location":"adr/00X-changelog_support/#status","title":"Status","text":"<p>Draft</p>"},{"location":"adr/00X-changelog_support/#context","title":"Context","text":"<p>Software documentation could benefit from the local newsletter, rss and email newsletter system.</p> <p>There are some changes that need to be done though. Instead of creating items per week, month or year, they should be created each time a release is made. Also, the template of the newsletter should be different.</p>"},{"location":"adr/00X-changelog_support/#proposals","title":"Proposals","text":"<ul> <li>Change the template to ...</li> <li>Select which changes are added to the changelog</li> <li>How do we configure the plugin so it knows it's in changelog mode</li> <li>The CI reacts to the tag event to rebuild the documentation and create the     newsletter.</li> </ul>"},{"location":"adr/00X-changelog_support/#decision","title":"Decision","text":""},{"location":"adr/00X-changelog_support/#consequences","title":"Consequences","text":""},{"location":"adr/adr/","title":"Architecture Decision Records","text":"<p>ADR are short text documents that captures an important architectural decision made along with its context and consequences.</p> <pre><code>graph TD\n    001[001: High level analysis]\n    002[002: Initial MkDocs plugin design]\n    003[003: Selected changes to record]\n    004[004: Article newsletter structure]\n    005[005: Article newsletter creation]\n    006[006: RSS feed creation]\n\n    001 -- Extended --&gt; 002\n    002 -- Extended --&gt; 003\n    002 -- Extended --&gt; 004\n    002 -- Extended --&gt; 005\n    002 -- Extended --&gt; 006\n    003 -- Extended --&gt; 004\n    004 -- Extended --&gt; 005\n\n    click 001 \"https://lyz-code.github.io/mkdocs-newsletter/adr/001-initial_approach\" _blank\n    click 002 \"https://lyz-code.github.io/mkdocs-newsletter/adr/002-initial_plugin_design\" _blank\n    click 003 \"https://lyz-code.github.io/mkdocs-newsletter/adr/003-select_the_changes_to_record\" _blank\n    click 004 \"https://lyz-code.github.io/mkdocs-newsletter/adr/004-article_newsletter_structure\" _blank\n    click 005 \"https://lyz-code.github.io/mkdocs-newsletter/adr/005-create_the_newsletter_articles\" _blank\n    click 006 \"https://lyz-code.github.io/mkdocs-newsletter/adr/006-rss_feed_creation\" _blank\n\n    001:::accepted\n    002:::accepted\n    003:::accepted\n    004:::accepted\n    005:::accepted\n    006:::accepted\n\n    classDef draft fill:#CDBFEA;\n    classDef proposed fill:#B1CCE8;\n    classDef accepted fill:#B1E8BA;\n    classDef rejected fill:#E8B1B1;\n    classDef deprecated fill:#E8B1B1;\n    classDef superseeded fill:#E8E5B1;</code></pre>"}]}